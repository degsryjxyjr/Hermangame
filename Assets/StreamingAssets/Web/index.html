<!DOCTYPE html>
<html>
<head>
    <title>Game Lobby</title>
    <link rel="stylesheet" type="text/css" href="styles.css">
</head>
<body onload="populateClassList()">
    <div id="joinView">
        <h2>Join Game</h2>
        <div class="input-group">
            <label>Room Code:</label>
            <input type="text" id="roomCodeInput" placeholder="Enter room code">
        </div>
        <div class="input-group">
            <label>Your Name:</label>
            <input type="text" id="nameInput" placeholder="Your player name">
        </div>
        <div class="input-group">
            <label>Class:</label>
            <select id="classSelect">
            </select>
        </div>

        <button onclick="joinGame()">Join Game</button>
    </div>

    <div id="lobbyView">
        <h2>Room: <span id="roomCodeDisplay"></span></h2>
        <div id="playerList"></div>
        <button id="readyButton" onclick="toggleReady()">Ready Up</button>
        <button id="startButton" onclick="startGame()" disabled>Start Game</button>
        <button onclick="disconnect()">Leave Lobby</button>
    </div>
    <div id="gameView">
        <div id="mapView">
            <h2>Map View</h2>
            <div id="mapContent">
                <!-- Map content (could be an image, canvas, or other elements) -->
                <p>Exploring the world...</p>
            </div>
        
            <!-- --- Party Display Section --- -->
            <div id="partyDisplay">
                <h3>Your Party</h3>
                <div id="partyMembersList">
                    <!-- Party members will be populated here dynamically -->
                    <!-- Example static structure (will be replaced by JS): -->
                    <!--
                    <div class="party-member" data-player-id="player123">
                        <img src="images/players/default-player.png" alt="Player Icon" class="party-member-icon">
                        <span class="party-member-name">Player One</span>
                        <span class="party-member-hp">HP: 50/100</span>
                    </div>
                    -->
                </div>
            </div>
            <!-- --- END  --- -->

            <!-- ---  Trade Request Notification (Hidden by default) --- -->
            <div id="tradeRequestNotification" class="notification" style="display:none;">
                <p><span id="tradeRequesterName">Someone</span> wants to trade with you!</p>
                <button id="acceptTradeRequest">Accept</button>
                <button id="declineTradeRequest">Decline</button>
            </div>
            <!-- --- END  --- -->
        </div>

        <!-- Inventory Button (floating action button for mobile) -->
        <button id="inventoryButton" class="fab">
            <img src="images/icons/backpack.jpg" alt="Inventory">
        </button>

        <!-- Player Stats Display -->
        <div id="playerStatsDisplay" class="stats-display">
            <h3 id="statsPlayerName">Player Name</h3>
            <p><strong>Class:</strong> <span id="statsPlayerClass">-</span></p>
            <p><strong>Level:</strong> <span id="statsPlayerLevel">-</span></p>
            <p><strong>XP:</strong> <span id="statsPlayerExperience">0</span></p>
            <p><strong>HP:</strong> <span id="statsCurrentHealth">0</span>/<span id="statsMaxHealth">0</span></p>
            <p><strong>ATK:</strong> <span id="statsAttack">0</span></p>
            <p><strong>DEF:</strong> <span id="statsDefense">0</span></p>
            <p><strong>MAG:</strong> <span id="statsMagic">0</span></p>
        </div>

        <!-- --- Trade View (Initially Hidden) --- -->
        <div id="tradeView" class="panel" style="display:none;">
            <h2>Trading</h2>
            <div id="tradePartnerInfo">
                <h3>Trading with: <span id="tradePartnerName">Partner</span></h3>
                <!-- Optionally show partner's class icon here too -->
            </div>

            <div class="trade-sections-container"> <!-- Container for side-by-side layout -->

                <div class="trade-section">
                    <h4>Your Inventory</h4>
                    <!-- --- MODIFIED: Replaced static text with dynamic grid --- -->
                    <div id="tradeYourInventory" class="trade-inventory-grid">
                        <!-- Your items for trading will be populated here dynamically -->
                        <!-- Example placeholder (will be cleared and filled by JS):
                        <div class="trade-inventory-item" data-item-id="item_wood">
                            <img src="images/items/wood.png" alt="Wood" class="trade-item-icon">
                            <span class="trade-item-name">Wood</span>
                            <span class="trade-item-quantity">x10</span>
                        </div>
                        -->
                    </div>
                    <!-- --- END MODIFIED --- -->
                    <div class="trade-offered-items">
                        <h5>Your Offer:</h5>
                        <div id="tradeYourOffer" class="trade-offer-grid">
                            <!-- Items you've added to the trade will appear here -->
                        </div>
                    </div>
                </div>

                <div class="trade-section">
                    <h4>Partner's Inventory</h4>
                    <div id="tradePartnerInventory" class="trade-inventory-grid">
                        <!-- Partner's items for trading will be populated here (if server sends them) -->
                        <!-- Or just a placeholder "Items not visible" message -->
                        <p>Partner's items are not visible.</p>
                    </div>
                    <div class="trade-offered-items">
                        <h5>Partner's Offer:</h5>
                        <div id="tradePartnerOffer" class="trade-offer-grid">
                            <!-- Partner's added items will appear here -->
                        </div>
                    </div>
                </div>

            </div> <!-- End trade-sections-container -->

            <div class="trade-actions">
                <button id="tradeConfirm">Confirm Trade</button>
                <button id="tradeCancel">Cancel Trade</button>
            </div>

            <div id="tradeMessages">
                <!-- Area for trade-specific messages/logs -->
            </div>
        </div>
        <!-- --- END --- -->



        <!-- Combat View Panel -->
        <div id="combatPanel">
            <div id="combatHeader">
                <h2>Combat Encounter</h2>
                <div id="combatStatus">Waiting for encounter to start...</div>
            </div>

            <div id="targetSelectionPrompt">Select a target for your action.</div>

            <div class="combat-section lists-and-actions">
                <h3>Players</h3>
                <div id="playerListCombat" class="entity-list">
                    <!-- Player entities will be populated here by JS -->
                </div>
            </div>

            <div class="combat-section lists-and-actions">
                <h3>Enemies</h3>
                <div id="enemyListCombat" class="entity-list">
                    <!-- Enemy entities will be populated here by JS -->
                </div>
            </div>

            <div class="combat-section lists-and-actions">
                <h3>Actions</h3>
                <div id="availableActions">
                    <!-- Action buttons (abilities, items, etc.) will be populated here by JS -->
                </div>
            </div>

            <!-- This is the section for the combat log -->
            <div class="combat-section combat-log-section">
                <h3>Combat Log</h3>
                <div id="combatLog">
                    <div id="combatLogEntries"></div>
                    <!-- Combat messages will appear here -->
                </div>
            </div>
        </div>


        <!-- Inventory Panel -->
        <div id="inventoryPanel">
            <div class="inventory-header">
                <h3>Inventory</h3>
                <button id="closeInventory">X</button>
            </div>
            <div id="equippedSection">
                <h4>Equipped</h4>
                <div id="equippedItems" class="equipped-grid">
                    <!-- Equipped items will be populated here -->
                    <!-- Example slot placeholders (optional) -->
                    <!--
                    <div class="equipped-slot" data-slot="Weapon"><span class="slot-name">Weapon</span></div>
                    <div class="equipped-slot" data-slot="Armor"><span class="slot-name">Armor</span></div>
                    <div class="equipped-slot" data-slot="Accessory"><span class="slot-name">Accessory</span></div>
                    -->
                </div>
            </div>
            <hr> <!-- Separator -->
            <div id="bagSection">
                <h4>Bag</h4>
                <div id="inventoryItems" class="inventory-grid">
                    <!-- Bag items will be populated here -->
                </div>
            </div>
        </div>
    </div>
    <div id="debugLog">Connecting...</div>

    <script>
        let ws;
        let currentPlayerId;
        let isReady = false;
        let debugInterval;
        let roomCode = '';
        let playerName = "Player Name";

        let currentPartyData = null;

        let isInCombat = false;
        let currentCombatState = null; // To store data sent by the server
        let selectedAction = null;
        let selectedTarget = null;


        // --- Trading Specific Variables ---
        let currentTradeSessionId = null;
        let isTradeActive = false; // Flag to track if we are in a trade view/session
        let tradeOffers = { // Local representation of what we've offered
            items: {} // itemId: quantity
        };
        // --- END ---

        /* ---- INVENTORY UI ---- */
        const inventoryButton = document.getElementById('inventoryButton');
        const inventoryPanel   = document.getElementById('inventoryPanel');
        const closeInventory   = document.getElementById('closeInventory');
        const inventoryItems   = document.getElementById('inventoryItems');
        let inventoryData      = [];

        /* ---- STAT UI CONST ---- */
        let playerStats = {
            // Initialize with default/empty values
            name: playerName,
            class: "-",
            level: 1,
            experience: 0, // Add experience property
            currentHealth: 0,
            maxHealth: 0,
            attack: 0,
            defense: 0,
            magic: 0,
            totalActions: 0,
            actionsRemaining: 0,
            abilities: [{}]
        };

        // --- helper function to update the stats display ---
        function updateStatsDisplay() {
            if (!playerStats) return; // Don't update if no stats yet

            document.getElementById('statsPlayerName').textContent = playerStats.name || "Unknown";
            document.getElementById('statsPlayerClass').textContent = playerStats.class || "-";
            document.getElementById('statsPlayerLevel').textContent = playerStats.level !== undefined ? playerStats.level : "-"; // Update level
            document.getElementById('statsPlayerExperience').textContent = playerStats.experience !== undefined ? playerStats.experience : "0"; // Update XP display
            document.getElementById('statsCurrentHealth').textContent = playerStats.currentHealth !== undefined ? playerStats.currentHealth : "0";
            document.getElementById('statsMaxHealth').textContent = playerStats.maxHealth !== undefined ? playerStats.maxHealth : "0";
            document.getElementById('statsAttack').textContent = playerStats.attack !== undefined ? playerStats.attack : "0";
            document.getElementById('statsDefense').textContent = playerStats.defense !== undefined ? playerStats.defense : "0";
            document.getElementById('statsMagic').textContent = playerStats.magic !== undefined ? playerStats.magic : "0";

            // Optional: Add visual feedback for low health
            const healthPercent = playerStats.maxHealth > 0 ? (playerStats.currentHealth / playerStats.maxHealth) : 0;
            const statsDisplay = document.getElementById('playerStatsDisplay');
            statsDisplay.classList.remove('low-health'); // Remove class first
            if (healthPercent < 0.3) { // Example: Red if below 30%
                statsDisplay.classList.add('low-health');
            }
        }





        // --- Ensure your existing toggleInventory function requests the full update ---
        function toggleInventory() {
            const panel = document.getElementById('inventoryPanel');
            const statsDisplay = document.getElementById('playerStatsDisplay'); // <-- Get stats display
            const isVisible = panel.style.display === 'block';
            panel.style.display = isVisible ? 'none' : 'block';

            // Adjust stats display visibility based on context
            if (statsDisplay) {
                if (isVisible) {
                    // Inventory closing
                    if (isInCombat) {
                        // Keep stats hidden in combat, or show combat-specific stats
                        statsDisplay.style.display = 'block';
                    } else {
                        // Show main stats outside combat
                        statsDisplay.style.display = 'block';
                    }
                } else {
                    // Inventory opening, hide stats in both cases probably
                    statsDisplay.style.display = 'none';
                }
            }

            // In combat, maybe also hide/show action buttons?
            const actionsDiv = document.getElementById('availableActions');
            if (actionsDiv && isInCombat) {
                actionsDiv.style.display = isVisible ? 'block' : 'none'; // Hide actions when inv open
            }

            if (!isVisible) { // If we are opening the panel
                sendMessage({ type: "inventory", action: "get" }); // Request full inventory data
            }
        }

        // Proper event listeners
        document.getElementById('inventoryButton').addEventListener('click', function(e) {
            e.preventDefault();
            toggleInventory();
        });

        document.getElementById('closeInventory').addEventListener('click', function(e) {
            e.preventDefault();
            toggleInventory();
        });

        // Handle clicks outside inventory content
        document.getElementById('inventoryPanel').addEventListener('click', function(e) {
            if (e.target === this) { // Clicked on backdrop
                toggleInventory();
            }
        });

        function handleInventoryData(inventoryUpdateData) {
            // --- Handle Bag Items (existing logic, slightly modified) ---
            const bagItems = inventoryUpdateData.items || []; // Ensure it's an array
            const bagContainer = document.getElementById('inventoryItems');
            bagContainer.innerHTML = ''; // Clear existing items

            if (bagItems.length === 0) {
                bagContainer.innerHTML = '<div class="empty-inventory">Your bag is empty</div>';
            } else {
                bagItems.forEach(item => {
                    const itemEl = createInventoryItemElement(item); // Reuse item creation logic
                    // Add click listener for using items from the bag
                    itemEl.addEventListener('click', () => {
                        sendMessage({ type: "inventory", action: "use", itemId: item.id });
                    });
                    bagContainer.appendChild(itemEl);
                });
            }

            // --- IMPORTANT: Update the global inventoryData variable ---
            inventoryData = bagItems; // This is crucial for updateTradeInventoryDisplay
            // --- END IMPORTANT ---

            // --- Handle Equipped Items (NEW LOGIC) ---
            const equippedData = inventoryUpdateData.equipped || {}; // Ensure it's an object
            const equippedContainer = document.getElementById('equippedItems');
            equippedContainer.innerHTML = ''; // Clear existing slots/items

            // Define your expected equipment slots (order matters for display)
            // Make sure these match the enum names used in C# (ItemDefinition.EquipmentSlot)
            const equipmentSlotOrder = ['MainHand', 'OffHand', 'Head', 'Body', 'Accessory'];

            equipmentSlotOrder.forEach(slotName => {
                const itemData = equippedData[slotName]; // Get item data for this slot, if any

                // Create a container for the slot
                const slotEl = document.createElement('div');
                slotEl.className = 'equipped-slot'; // Base class for styling
                slotEl.dataset.slot = slotName; // Store slot name for potential future use

                if (itemData) {
                    // Slot is filled
                    slotEl.classList.add('filled');

                    // Create the equipped item element (similar to bag item)
                    const equippedItemEl = createInventoryItemElement(itemData);

                    // Optional: Add specific class or behavior for equipped items
                    equippedItemEl.classList.add('equipped-item');

                    // Add click listener to potentially unequip or show details
                    // Here, we'll use the "equip" action, which should toggle it off
                    // according to your C# logic (PlayerInventory.EquipItem)
                    equippedItemEl.addEventListener('click', () => {
                        sendMessage({ type: "inventory", action: "use", itemId: itemData.id });
                        // Or send "use" if that's the intended way to toggle equipment
                        // sendMessage({ type: "inventory", action: "use", itemId: itemData.id });
                    });

                    // Clear default content and add the item
                    slotEl.innerHTML = '';
                    slotEl.appendChild(equippedItemEl);

                } else {
                    // Slot is empty
                    // Display the slot name or an empty indicator
                    const slotNameEl = document.createElement('span');
                    slotNameEl.className = 'slot-name';
                    slotNameEl.textContent = slotName;
                    slotEl.appendChild(slotNameEl);
                    // You might add a visual "empty slot" icon here too if desired
                }

                equippedContainer.appendChild(slotEl);
            });

            // --- Show the inventory panel if it's not already visible ---
            // (This part was already handled by toggleInventory calling this function)
        }
        // --- Helper function to create an inventory item element ---
        // This avoids duplicating the creation logic for bag and equipped items
        function createInventoryItemElement(item, isForTrade = false) {
            // --- MODIFIED: Allow different base class for trade items ---
            const baseClassName = isForTrade ? 'trade-inventory-item' : 'inventory-item';
            // --- END MODIFIED ---
            const itemEl = document.createElement('div');
            itemEl.className = baseClassName;

            // --- Create the image element ---
            const imgEl = document.createElement('img');
            imgEl.alt = item.name || 'Item';
            imgEl.className = 'item-icon';

            // --- Implement PNG/JPG fallback logic ---
            let basePath = item.icon || 'images/icons/default-item.jpg';
            if (basePath === 'images/icons/default-item.jpg') {
                imgEl.src = basePath;
            } else {
                imgEl.src = `${basePath}.png`;
                imgEl.onerror = function () {
                    console.warn(`Failed to load PNG icon: ${this.src}. Trying JPG...`);
                    this.src = `${basePath}.jpg`;
                    this.onerror = function () {
                        console.warn(`Failed to load JPG icon: ${this.src}. Loading default.`);
                        this.src = 'images/icons/default-item.jpg';
                    };
                };
            }

            // --- Create name element ---
            const nameEl = document.createElement('span');
            nameEl.className = 'item-name';
            nameEl.textContent = item.name || 'Unknown Item';

            // --- Create quantity element (if applicable and > 1) ---
            // ---  Always show quantity in trade view, even if 1 ---
            let quantityEl = null;
            const quantityToShow = isForTrade ? item.quantity : (item.quantity && item.quantity > 1 ? item.quantity : null);
            if (quantityToShow !== null && quantityToShow !== undefined) {
                quantityEl = document.createElement('span');
                // --- MODIFIED: Reuse CSS class for trade view if needed ---
                quantityEl.className = 'item-quantity'; // Or 'trade-item-quantity' if distinct styles are needed
                quantityEl.textContent = `x${quantityToShow}`;
            }

            // --- Assemble the item element ---
            itemEl.appendChild(imgEl);
            itemEl.appendChild(nameEl);
            if (quantityEl) {
                itemEl.appendChild(quantityEl);
            }

            // --- : Add trade-specific data attributes and click listener if needed ---
            if (isForTrade) {
                itemEl.dataset.itemId = item.id; // Store item ID
                itemEl.dataset.itemQuantity = item.quantity; // Store quantity for reference
                // The click listener will be added by the caller (updateTradeInventoryDisplay)
                // to have access to trade-specific variables like currentTradeSessionId.
                // Alternatively, you could pass a callback function here.
            }
            // --- END  ---

            return itemEl;
        }
        /* ---- INVENTORY UI END---- */

        // --- NEW: Function to update the trade inventory display ---
        // This uses the global inventoryData variable, assumed to be kept up-to-date by handleInventoryData
        // --- MODIFIED: Simplified updateTradeInventoryDisplay using createInventoryItemElement ---
        function updateTradeInventoryDisplay() {
            const tradeInventoryGrid = document.getElementById('tradeYourInventory');
            console.log("updateTradeInventoryDisplay called");
            console.log("Current inventoryData:", inventoryData);

            if (!tradeInventoryGrid) {
                console.warn("Trade inventory grid element not found.");
                return;
            }

            // Clear existing items
            tradeInventoryGrid.innerHTML = '';

            if (!inventoryData) {
                console.warn("inventoryData is null or undefined.");
                tradeInventoryGrid.innerHTML = '<div class="trade-inventory-empty">Inventory data not loaded.</div>';
                return;
            }

            if (!Array.isArray(inventoryData)) {
                console.error("inventoryData is not an array:", typeof inventoryData, inventoryData);
                tradeInventoryGrid.innerHTML = '<div class="trade-inventory-empty">Error loading inventory.</div>';
                return;
            }

            if (inventoryData.length === 0) {
                console.log("inventoryData array is empty.");
                tradeInventoryGrid.innerHTML = '<div class="trade-inventory-empty">Your inventory is empty.</div>';
                return;
            }

            // Filter out items with quantity <= 0
            const validItems = inventoryData.filter(item => {
                const isValid = item.quantity > 0;
                if (!isValid) {
                    console.log(`Skipping item ${item.id} because quantity is ${item.quantity}`);
                }
                return isValid;
            });

            console.log("Valid items found for trade:", validItems.length);

            if (validItems.length === 0) {
                tradeInventoryGrid.innerHTML = '<div class="trade-inventory-empty">No items available to trade.</div>';
                return;
            }

            // Iterate through valid items and create display elements using the helper
            validItems.forEach(item => {
                // --- NEW: Use the reusable helper function ---
                const itemDiv = createInventoryItemElement(item, true); // true indicates it's for trade
                // --- END NEW ---

                // --- NEW: Add Trade-Specific Click Listener ---
                // Add the click listener here, as the helper now prepares the element for it.
                itemDiv.addEventListener('click', function() {
                    if (!isTradeActive || !currentTradeSessionId) {
                        logTradeMessage("Not in an active trade session.", 'warn');
                        return;
                    }

                    const itemId = this.dataset.itemId;
                    const itemName = item.name || 'Unknown Item';
                    const maxQuantity = parseInt(this.dataset.itemQuantity, 10) || 0;

                    if (!itemId || maxQuantity <= 0) {
                        logTradeMessage("Invalid item selected.", 'error');
                        return;
                    }

                    let quantityStr = prompt(`How many ${itemName} do you want to add? (Max: ${maxQuantity})`, "1");
                    let quantityToAdd = parseInt(quantityStr, 10);

                    if (isNaN(quantityToAdd) || quantityToAdd <= 0) {
                        logTradeMessage("Invalid quantity entered.", 'warn');
                        return;
                    }

                    if (quantityToAdd > maxQuantity) {
                        quantityToAdd = maxQuantity;
                        logTradeMessage(`Quantity capped to available amount: ${quantityToAdd}`, 'info');
                    }

                    sendMessage({
                        type: "trade",
                        trade_action: "add_item",
                        session_id: currentTradeSessionId,
                        item_id: itemId, // Use 'id'
                        quantity: quantityToAdd
                    });
                    logTradeMessage(`Attempting to add ${quantityToAdd}x ${itemName} to trade.`, 'info');
                });
                // --- END NEW ---

                // Append the configured item div to the trade inventory grid
                tradeInventoryGrid.appendChild(itemDiv);
            });
            console.log("Finished populating trade inventory grid.");
        }



        // ---  Update Map View Function ---
        // This needs to be called when entering the map view or when party data updates.
        function updateMapView(partyData) {
            const partyListElement = document.getElementById('partyMembersList');
            if (!partyListElement) {
                console.warn("Party list element not found in DOM.");
                return;
            }

            // Clear existing list
            partyListElement.innerHTML = '';

            if (!partyData || !partyData.party.members || partyData.party.members.length === 0) {
                partyListElement.innerHTML = '<p>Your party is empty.</p>';
                return;
            }

            // Iterate through party members and create display elements
            partyData.party.members.forEach(member => {
                // Create the main container div for the member
                const memberDiv = document.createElement('div');
                memberDiv.className = 'party-member';
                memberDiv.dataset.playerId = member.id; // Store player ID for click events

                // Create and set the icon
                const iconImg = document.createElement('img');
                iconImg.src = member.iconPath || 'images/players/default-player.png'; // Use path from data or default
                iconImg.alt = `${member.name || 'Player'} Icon`;
                iconImg.className = 'party-member-icon';

                // Create and set the name
                const nameSpan = document.createElement('span');
                nameSpan.className = 'party-member-name';
                nameSpan.textContent = member.name || 'Unknown Player';

                // Create and set the HP
                const hpSpan = document.createElement('span');
                hpSpan.className = 'party-member-hp';
                // Format HP display, handling potential undefined values
                const currentHp = member.currentHealth !== undefined ? member.currentHealth : '?';
                const maxHp = member.maxHealth !== undefined ? member.maxHealth : '?';
                hpSpan.textContent = `HP: ${currentHp}/${maxHp}`;

                // Append elements to the member div
                memberDiv.appendChild(iconImg);
                memberDiv.appendChild(nameSpan);
                memberDiv.appendChild(hpSpan);

                // --- NEW: Add Click Listener for Trading ---
                memberDiv.addEventListener('click', function() {
                    const targetPlayerId = this.dataset.playerId;
                    const targetPlayerName = member.name || 'Unknown Player';
                    if (targetPlayerId && targetPlayerId !== currentPlayerId) {
                        // Prevent trading with yourself
                        console.log(`Requesting trade with player ID: ${targetPlayerId}`);
                        // Send trade request message to server
                        sendMessage({
                            type: "trade",
                            trade_action: "request",
                            target_player_id: targetPlayerId
                        });
                        logDebug(`Trade request sent to ${targetPlayerName} (${targetPlayerId})`, 'info');
                    } else if (targetPlayerId === currentPlayerId) {
                        logDebug("You cannot trade with yourself.", 'warn');
                    }
                });
                // --- END NEW ---

                // Append the member div to the list
                partyListElement.appendChild(memberDiv);
            });
        }
        // --- END  ---


        // --- : Show/Hide Trade Request Notification ---
        function showTradeRequest(requesterId, requesterName, sessionId) { // Add sessionId parameter
            const notification = document.getElementById('tradeRequestNotification');
            const requesterNameSpan = document.getElementById('tradeRequesterName');
            if (notification && requesterNameSpan) {
                requesterNameSpan.textContent = requesterName;
                notification.dataset.requesterId = requesterId;
                // --- : Store the session ID on the notification element ---
                if (sessionId) {
                    notification.dataset.sessionId = sessionId; // Store Session ID
                } else {
                    console.error("showTradeRequest called without sessionId!");
                    delete notification.dataset.sessionId; // Ensure it's not set if missing
                }
                // --- END  ---
                notification.style.display = 'block';
                logDebug(`Trade request received from ${requesterName}`, 'info');
            }
        }

        function hideTradeRequest() {
            const notification = document.getElementById('tradeRequestNotification');
            if (notification) {
                notification.style.display = 'none';
                delete notification.dataset.requesterId; // Clear stored requester ID
                delete notification.dataset.sessionId; // Clear stored Trading Session ID
            }
        }
        // --- END ---

        // --- Toggle Trade View ---
        function toggleTradeView(show = null) {
            const tradeView = document.getElementById('tradeView');
            const mapView = document.getElementById('mapView'); // Assuming mapView is the main map container
            if (!tradeView || !mapView) {
                console.error("Trade view or Map view element not found.");
                return;
            }

            const isVisible = tradeView.style.display !== 'none';

            // Determine the desired state
            const shouldShow = show === null ? !isVisible : show; // If show is null, toggle. Otherwise, set to 'show'.

            if (shouldShow) {
                tradeView.style.display = 'block';
                mapView.style.display = 'none'; // Hide map view when trade is active
                isTradeActive = true;
                logDebug("Trade view opened.", 'info');
                
                // Populate the trade inventory when the view opens ---
                // This ensures it reflects the latest inventory state
                updateTradeInventoryDisplay();

                // Optionally request initial trade data or inventory snapshot here
                // sendMessage({ type: "trade", trade_action: "get_inventory" }); // If needed
            } else {
                tradeView.style.display = 'none';
                mapView.style.display = 'block'; // Show map view when trade is closed
                isTradeActive = false;
                logDebug("Trade view closed.", 'info');
                // Clear trade state/UI if needed?
                clearTradeView();
            }
        }

        function clearTradeView() {
            // Reset local trade state
            currentTradeSessionId = null;
            tradeOffers = { items: {} };

            // Clear UI elements
            document.getElementById('tradePartnerName').textContent = 'Partner';
            document.getElementById('tradeYourInventory').innerHTML = '';
            document.getElementById('tradePartnerInventory').innerHTML = '<p>Partner\'s items are not visible.</p>';
            document.getElementById('tradeYourOffer').innerHTML = '';
            document.getElementById('tradePartnerOffer').innerHTML = '';
            document.getElementById('tradeMessages').innerHTML = '';
            logDebug("Trade view cleared.", 'info');
        }
        // --- END NEW ---

        function logDebug(message, category = "system") { // Add category parameter
            const debugElement = document.getElementById('debugLog');
            const combatLogEntriesElement = document.getElementById('combatLogEntries'); // Get the inner container

            const timestamp = new Date().toLocaleTimeString();
            const logEntry = `${timestamp}: ${message}`;

            if (isInCombat && combatLogEntriesElement) {
                // --- Route to Combat Log ---
                const entryEl = document.createElement('div');
                // Use the category to style the message, defaulting to 'system' if not provided or invalid
                const validCategories = ['player', 'enemy', 'system', 'damage', 'heal', 'info', 'warning', 'error', 'success'];
                const logCategory = validCategories.includes(category) ? category : 'system';
                entryEl.className = `combat-log-entry combat-log-${logCategory}`;
                entryEl.textContent = `[${timestamp}] ${message}`; // Include timestamp in combat log entry text as well
                combatLogEntriesElement.appendChild(entryEl);
                // Scroll the specific log entries container
                combatLogEntriesElement.scrollTop = combatLogEntriesElement.scrollHeight;
            } else if (debugElement) {
                // --- Route to Debug Log ---
                debugElement.innerHTML += `${logEntry}<br>`;
                debugElement.scrollTop = debugElement.scrollHeight;
            }
            // If neither element is found, the message is effectively discarded,
            // which is fine as the elements might not exist in certain view states.
        }

        function populateClassList() {
            fetch('/api/classes')
                .then(r => r.json())
                .then(classes => {
                    const sel = document.getElementById('classSelect');
                    sel.innerHTML = '';
                    classes.forEach(c => {
                        const opt = document.createElement('option');
                        opt.value = c.className;
                        opt.textContent = c.className;
                        opt.dataset.icon = c.iconPath;  // Store the icon path if needed
                        sel.appendChild(opt);
                    });
                    logDebug(`Loaded ${classes.length} classes`);
                })
                .catch(err => logDebug(`Failed to load classes: ${err}`));
        }

        function joinGame() {
            roomCode = document.getElementById('roomCodeInput').value.trim();
            const name = document.getElementById('nameInput').value.trim();
            const className = document.getElementById('classSelect').value;

            if (!roomCode || !name) {
                logDebug("Please enter room code and name");
                return alert("Please enter room code and name");
            }

            logDebug(`Connecting to room ${roomCode} as ${name} (${className})...`);
            playerName = name;
            ws = new WebSocket(`ws://${window.location.hostname}:9000/game`);

            ws.onopen = () => {
                ws.send(JSON.stringify({
                    type: "join",
                    roomCode: roomCode,
                    name: name,
                    class: className 
                }));
            };

            ws.onmessage = (e) => {
                const msg = JSON.parse(e.data);
                handleServerMessage(msg);
            };

            ws.onclose = () => {
                logDebug("Disconnected from server");
                document.getElementById('joinView').style.display = 'block';
                document.getElementById('lobbyView').style.display = 'none';
                document.getElementById('gameView').style.display = 'none'; 
                playerName = null;
            };

            ws.onerror = (err) => {
                logDebug(`WebSocket error: ${err.message}`);
            };
        }

        function handleServerMessage(msg) {
            switch(msg.type) {
                case "join_success":
                    currentPlayerId = msg.playerId;
                    document.getElementById('roomCodeDisplay').textContent = roomCode;
                    document.getElementById('joinView').style.display = 'none';
                    document.getElementById('lobbyView').style.display = 'block';
                    playerStats.name = msg.profile.name;
                    logDebug(`Joined successfully as ${msg.profile.name}`);
                    break;
                    
                case "join_error":
                    logDebug(`Join failed: ${msg.message}`);
                    alert(msg.message);
                    break;
                    
                case "lobby_update":
                    updatePlayerList(msg.players);
                    document.getElementById('startButton').disabled = !msg.canStart;
                    logDebug(`Player list updated (${msg.players.length} players)`);
                    break;
                case "game_state_change":
                    switch (msg.state) {
                        case "Map":
                            
                            document.getElementById('lobbyView').style.display = 'none';
                            document.getElementById('gameView').style.display = 'block';
                            
                            // Ensure inventory is hidden when game starts
                            document.getElementById('inventoryPanel').style.display = 'none';

                            // ensure tradeView is hidden when game starts
                            document.getElementById('tradeView').style.display = 'none';

                            // --- Update Map View Party Display ---
                            // When entering the map view, use the stored party data to populate the display
                            if (currentPartyData) {
                                updateMapView(currentPartyData);
                            } else {
                                console.warn("Entering Map view, but no party data is currently stored.");
                                // Optionally, request party data if it's unexpectedly missing?
                                // sendMessage({ type: "party", action: "get" }); // Example request
                                // Or, clear the display
                                updateMapView(null); // This will show "Your party is empty."
                            }

                            // <-- Show stats display when game starts -->
                            const statsDisplayElement = document.getElementById('playerStatsDisplay');
                            if (statsDisplayElement) {
                                statsDisplayElement.style.display = 'block'; // Show stats
                                updateStatsDisplay(); // Update with any previously received stats
                            }
                            break;
                        case "Lobby":
                            document.getElementById('gameView').style.display = 'none';
                            document.getElementById('lobbyView').style.display = 'block';
                            // <-- Hide stats display when back to lobby -->
                            const statsDisplayElementLobby = document.getElementById('playerStatsDisplay');
                            if (statsDisplayElementLobby) {
                                statsDisplayElementLobby.style.display = 'none';
                            }
                            break;

                        case "Combat":
                            enterCombatMode();
                            break;
                    }
                    break;

                case "inventory_update":
                    // Pass the entire message object, not just msg.items
                    handleInventoryData(msg);
                    break;

                // <-- case for stats_update -->
                case "stats_update":
                    // Store the received stats data, including level and experience
                    // Ensure playerStats.name is set correctly on join_success or elsewhere if needed
                    playerStats.name = playerStats.name || "Player"; // Use existing name or default
                    // Update stats only if they are present in the message
                    if (msg.hasOwnProperty('role')) playerStats.class = msg.role; // this is role cause cant send class in C
                    if (msg.hasOwnProperty('level')) playerStats.level = msg.level;
                    if (msg.hasOwnProperty('experience')) playerStats.experience = msg.experience; // Handle XP update
                    if (msg.hasOwnProperty('currentHealth')) playerStats.currentHealth = msg.currentHealth;
                    if (msg.hasOwnProperty('maxHealth')) playerStats.maxHealth = msg.maxHealth;
                    if (msg.hasOwnProperty('attack')) playerStats.attack = msg.attack;
                    if (msg.hasOwnProperty('defense')) playerStats.defense = msg.defense;
                    if (msg.hasOwnProperty('magic')) playerStats.magic = msg.magic;
                    if (msg.hasOwnProperty('totalActions')) playerStats.totalActions = msg.totalActions;
                    if (msg.hasOwnProperty('actionsRemaining')) playerStats.actionsRemaining = msg.actionsRemaining;

                    // --- Handle Abilities Update ---
                    // Only update abilities if they are explicitly sent in the message
                    if (msg.hasOwnProperty('abilities')) {
                        // Store the full abilities array received from the server
                        playerStats.abilities = msg.abilities; // This is now the simplified list from the server

                        // --- Optional: Update Action Buttons if in Combat and it's the Player's Turn ---
                        // This ensures the UI reflects new abilities immediately (e.g., after leveling up or equipping an item)
                        if (isInCombat &&
                            currentCombatState &&
                            currentCombatState.currentTurnEntity &&
                            currentCombatState.currentTurnEntity.type === 'player' &&
                            currentCombatState.currentTurnEntity.id === currentPlayerId) { // Use ID for robustness

                            // Rebuild the action buttons to include the new abilities
                            updateActionButtons(currentCombatState.currentTurnEntity.name);
                            console.log("Updated action buttons with new abilities received in stats_update.");
                        }
                    }
                    // --- End of Abilities Handling ---

                    // Update the display with the new stats
                    updateStatsDisplay();
                    break;
                    // <-- End of stats_update case -->
                case "encounter_start":
                    // This message contains the initial data to populate the combat view
                    if (msg.status === 'active') {
                        // Store the initial state if needed for later reference
                        currentCombatState = {
                            players: msg.players,
                            enemies: msg.enemies,
                            turnOrder: msg.turnOrder
                            // Add other relevant top-level data from encounter_start if needed
                        };

                        // Crucially, call updateCombatView with the data from encounter_start
                        // This should populate the player/enemy lists and initial state
                        updateCombatView(msg); // <-- This is the key call

                        logDebug(msg.message || "Encounter started!", 'info');
                    } else {
                        // Handle other statuses like 'victory', 'defeat' if they come through this message
                        logDebug(`Encounter start message received with status: ${msg.status}`, 'warning');
                    }
                    break;

                case 'encounter_end': // Message sent by CombatService/EncounterManager
                    exitCombatMode();
                    // msg might contain result (victory/defeat)
                    logCombatMessage(`Encounter ended. Result: ${msg.result}`, "system");
                    // Maybe show a victory/defeat message or automatically transition?
                    break;

                case 'turn_start':
                    // This message indicates whose turn it is
                    // Update the stored state and highlight the current entity
                    if (!currentCombatState) {
                        console.error("Received 'turn_start' but currentCombatState is not initialized.");
                        currentCombatState = {}; // Initialize to prevent further errors, but state might be inconsistent
                    }
                    currentCombatState.currentTurnEntity = msg.entity; // Store the current entity info

                    // Highlight the entity whose turn it is (e.g., add a CSS class)
                    highlightCurrentTurnEntity(msg.entity); // You already have this function

                    // Optional: Update action buttons if it's the local player's turn
                    // This might also be handled inside highlightCurrentTurnEntity
                    if (msg.entity.type === 'player' && msg.entity.id === currentPlayerId) {
                        updateActionButtons(msg.entity.name); // Enable actions for the player
                    } else {
                        // Disable actions or show waiting message for other turns
                        const actionContainer = document.getElementById('availableActions');
                        if (actionContainer) {
                            actionContainer.innerHTML = '<div class="log-entry info">Waiting for other turns...</div>';
                        }
                    }

                    logDebug(msg.message || `${msg.entity.name}'s turn begins!`, 'info');
                    break;

                case 'stats_update':
                    // This might be sent for players or enemies during combat
                    // Update the relevant HP bar in the combat view
                    updateCombatantStats(msg); // Implement this function
                    break;

                // Inside your main message switch statement
                case 'enemy_defeated':
                    logDebug(msg.message || "An enemy has been defeated!", 'success');
                    if (msg.enemyId) {
                        removeEnemyFromCombatView(msg.enemyId);
                        // Optional: Play a sound or animation if you have them
                    } else {
                        console.warn("Received 'enemy_defeated' message without 'enemyId':", msg);
                    }
                    break;

                case 'ability_effect':
                    // This message contains the result of an ability (damage, heal, etc.)
                    logCombatMessage(msg.message, "system"); // Or determine player/enemy source
                    // If msg contains numerical data, update stats here too
                    if (msg.targetStats) { // Example: server sends updated target stats
                        updateCombatantStats(msg.targetStats);
                    }
                    break;

                case 'combat_entity_update': 
                    // This message updates a specific entity's stats (e.g., HP after damage/heal)
                    if (msg.entityId && msg.stats) {
                        updateCombatantStats({
                            id: msg.entityId,
                            type: msg.entityType, // 'player' or 'enemy'
                            ...msg.stats
                        });
                    } else {
                        console.warn("Received 'combat_entity_update' message with missing 'entityId' or 'stats':", msg);
                    }
                    break;
                case 'combat_entities_update': 
                    // This message updates a all entities' stats (e.g., HP after damage/heal)
                    // Store the initial state if needed for later reference
                    currentCombatState = {
                        players: msg.players,
                        enemies: msg.enemies
                        // Add other relevant top-level data from encounter_start if needed
                    };

                    // Crucially, call updateCombatView with the data from encounter_start
                    // This should populate the player/enemy lists and initial state
                    updateCombatView(msg); // <-- This is the key call

                    logDebug(msg.message || "Updated all entities' stats");
                    break;

                case 'combat_message':
                    // Properly handle combat log messages
                    if (msg.message) {
                        logCombatMessage(msg.message, msg.category || "system");
                    }
                    break;

                case 'combat_log': // Specific log messages from server
                    logCombatMessage(msg.message, msg.category || "system"); // category could be 'player', 'enemy', 'damage', 'heal'
                    break;

                case 'party_update':
                    // Store the full party data message for later use (e.g., on map view entry)
                    currentPartyData = msg;
                    console.log("Party data updated:", currentPartyData);

                    // --- Check if we are currently on the map view and update it ---
                    // This ensures the map view party display is updated whenever new party data arrives,
                    // regardless of how it got there (initial load, player joined/lef, stats changed, etc.)
                    const mapViewElement = document.getElementById('mapView');
                    if (mapViewElement && mapViewElement.style.display !== 'none') {
                        updateMapView(currentPartyData);
                        console.log("Map view party display updated due to party_update message.");
                    }

                    // --- Also update any other UI elements that depend on party data ---
                    // If you have a lobby view party list or similar, update it here.
                    // Example (if you had a function like this):
                    // updateLobbyPartyList(msg.members);

                    // --- END NEW ---
                    break;
                
                // ---: Trading Related Messages ---
                case 'trade_status':
                    handleTradeStatus(msg);
                    break;
                case 'trade_update':
                    handleTradeUpdate(msg);
                    break;

                case 'trade_error': // Handle specific trade errors if your server sends them
                    break;

                case 'error': // Or generic errors related to trade actions
                    if (msg.message && isTradeActive) {
                        logTradeMessage(`Error: ${msg.message}`, 'error');
                    } else if (msg.message) {
                        logDebug(`Error: ${msg.message}`, 'error'); // Log general errors
                    }
                    break;
                // --- END NEW ---
                default:
                    logDebug(`Unknown message type: ${msg.type}`);
            }
        }


        // --- NEW: Trade Message Handlers ---
        function handleTradeStatus(msg) {
            const status = msg.status;
            const sessionId = msg.session_id;
            const reason = msg.reason;

            switch(status) {
                case 'request_sent':
                    // This is an ack that our request was sent (optional handling)
                    logTradeMessage("Trade request sent. Waiting for response...", 'info');
                    break;

                case 'trade_request': // This is the incoming request *to* the current player
                    const requesterId = msg.requester_player_id;
                    const requesterName = msg.requester_player_name || 'Unknown Player';
                    // Get the session ID from the message ---
                    const tradeSessionId = msg.session_id; // Get the session ID sent by the server
                    if (requesterId) {
                        // --- MODIFIED: Pass the session ID to showTradeRequest ---
                        showTradeRequest(requesterId, requesterName, tradeSessionId); // Pass Session ID
                    }
                    break;
                // --- : Handle confirmation of adding an item to YOUR offer ---
                case 'item_added':
                    // Server confirms an item was added to YOUR offer
                    const addedItemInfo = {
                        id: msg.item_id,
                        quantity: msg.new_total_quantity || msg.quantity_added || 1 // Prefer total quantity
                        // Name/Icon could be included by server if needed immediately, otherwise we can try to find it
                        // in inventoryData. Let's assume name/icon might be needed, request if not present?
                        // For now, let's see if we can get name/icon from inventoryData or use defaults.
                    };
                    // Update your offer display
                    updateYourOfferDisplay(addedItemInfo, true); // true = add/update
                    logTradeMessage(`Added ${msg.quantity_added || 1}x ${msg.item_id} to your offer.`, 'info');
                    break;
                // --- END  ---
                case 'item_removed':
                    // Server confirms an item was removed from YOUR offer
                    const removedItemInfo = {
                        id: msg.item_id,
                        quantity: msg.new_total_quantity || 0 // Prefer total remaining quantity
                    };
                    // Update your offer display
                    updateYourOfferDisplay(removedItemInfo, false); // false = remove
                    logTradeMessage(`Removed item (${msg.item_id}) from your offer.`, 'info');
                    // If new_total_quantity > 0, it was a partial removal.
                    if (msg.new_total_quantity > 0) {
                        logTradeMessage(`(Quantity reduced by ${msg.quantity_removed || 1})`, 'info');
                    }
                    break;


                case 'started':
                    // Trade session is active, open the trade view
                    if (sessionId) {
                        currentTradeSessionId = sessionId;
                        const partnerName = msg.partner_name || 'Partner';
                        document.getElementById('tradePartnerName').textContent = partnerName;
                        toggleTradeView(true); // Show trade view
                        logTradeMessage(`Trade started with ${partnerName}. Session ID: ${sessionId}`, 'info');
                    }
                    break;
                case 'declined':
                    logTradeMessage(`Trade request declined.${reason ? ' Reason: ' + reason : ''}`, 'warn');
                    // Optionally hide request notification if it was shown
                    hideTradeRequest();
                    break;
                case 'cancelled':
                    logTradeMessage(`Trade cancelled.${reason ? ' Reason: ' + reason : ''}`, 'info');
                    if (isTradeActive) {
                        toggleTradeView(false); // Close trade view if it was open
                    }
                    hideTradeRequest(); // Also hide notification
                    break;
                case 'completed':
                    logTradeMessage("Trade completed successfully!", 'success');
                    toggleTradeView(false); // Close trade view
                    // Optionally trigger an inventory update?
                    sendMessage({ type: "inventory", action: "get" });
                    break;
                case 'failed':
                    const failReason = reason || 'Unknown error.';
                    logTradeMessage(`Trade failed. ${failReason}`, 'error');
                    if (isTradeActive) {
                        toggleTradeView(false); // Close trade view
                    }
                    break;
                case 'error': // If trade_status is also used for errors
                    const errorMsg = reason || 'An error occurred.';
                    logTradeMessage(`Trade error. ${errorMsg}`, 'error');
                    if (isTradeActive) {
                        toggleTradeView(false); // Close trade view on error?
                    }
                    break;
                default:
                    console.warn(`Unknown trade status: ${status}`, msg);
                    logTradeMessage(`Unknown trade status received: ${status}`, 'warn');
            }
        }

        function handleTradeUpdate(msg) {
            const updateType = msg.update_type;
            switch(updateType) {
                // --- Handle partner adding an item to THEIR offer ---
                case 'partner_item_added':
                    // Server tells us the partner added an item to their offer
                    // Try to get name/icon from message, fallback to defaults
                    const partnerAddedItemInfo = {
                        id: msg.item_id,
                        name: msg.item_name || 'Unknown Item', // Server might send this
                        quantity: msg.quantity || 1,
                        iconPath: msg.icon || 'images/items/default-item.png' // Server might send this
                    };
                    // Add/update the item in the partner's offer display
                    updatePartnerOfferDisplay(partnerAddedItemInfo, true); // true = add/update
                    const partnerName = msg.partner_name || 'Partner'; // Server might send this
                    logTradeMessage(`${partnerName} added ${partnerAddedItemInfo.quantity}x ${partnerAddedItemInfo.name} to their offer.`, 'info');
                    break;
                // --- END NEW ---
                


                // --- NEW: Handle partner removing an item from THEIR offer ---
                // --- MODIFIED: Handle partner removing an item from THEIR offer ---
                case 'partner_item_removed':
                    // Server tells us the partner removed an item from their offer
                    const partnerRemovedItemInfo = {
                        id: msg.item_id,
                        // For updatePartnerOfferDisplay(isAdding=false), we need to pass the quantity that was REMOVED
                        quantity: msg.quantity || 1 // Quantity removed (this is what updatePartnerOfferDisplay expects now)
                        // Name/icon are less critical for removal, but could be included if sent by server
                        // name: msg.item_name || 'Unknown Item',
                        // iconPath: msg.icon_path || 'images/items/default-item.png'
                    };
                    // Remove/reduce the item in the partner's offer display
                    updatePartnerOfferDisplay(partnerRemovedItemInfo, false); // false = remove
                    const partnerNameRemoved = msg.partner_name || 'Partner';
                    logTradeMessage(`${partnerNameRemoved} removed ${partnerRemovedItemInfo.quantity}x item (${partnerRemovedItemInfo.id}) from their offer.`, 'info');
                    break;
                // --- END  ---

                case 'partner_confirmed':
                    logTradeMessage(`${msg.partner_name || 'Partner'} has confirmed the trade.`, 'info');
                    // Visually indicate partner confirmation if desired (e.g., highlight their section)
                    break;
                // Add other update types as needed (e.g., partner cancelled, inventory snapshot if sent)

                default:
                    console.log(`Unhandled trade update type: ${updateType}`, msg);
                    // Log generic update message?
                    if (msg.message) {
                        logTradeMessage(msg.message, 'info');
                    }
            }
        }

        // --- MODIFIED: updateYourOfferDisplay function ---
        /// <summary>
        /// Updates the display of items in YOUR offer grid.
        /// </summary>
        /// <param name="itemInfo">Object containing item details (id, quantity, name, iconPath).</param>
        /// <param name="isAdding">True to add/update the item, false to remove it.</param>
        function updateYourOfferDisplay(itemInfo, isAdding) {
            const offerGrid = document.getElementById('tradeYourOffer');
            if (!offerGrid) {
                console.error("Your offer grid element (#tradeYourOffer) not found.");
                return;
            }

            const itemId = itemInfo.id;
            const itemElementId = `trade-your-offer-item-${itemId}`;
            let itemElement = document.getElementById(itemElementId);

            if (isAdding) {
                // --- Find item details in inventoryData for name/icon (if not provided) ---
                let itemName = itemInfo.name;
                let itemIconPath = itemInfo.iconPath;
                if (!itemName || !itemIconPath) {
                    const inventoryItem = inventoryData?.find(item => item.id === itemId);
                    if (inventoryItem) {
                        itemName = itemName || inventoryItem.name || 'Unknown Item';
                        itemIconPath = itemIconPath || inventoryItem.icon || 'images/icons/default-item.png';
                    } else {
                        // Fallback if not found in inventory (shouldn't happen normally for items you add)
                        itemName = itemName || itemInfo.id || 'Unknown Item';
                        itemIconPath = itemIconPath || 'images/items/default-item.png';
                    }
                }
                // --- End find item details ---

                // --- NEW: Use createInventoryItemElement helper ---
                // Create a temporary item object with the data we have for the helper
                const tempItemForHelper = {
                    id: itemId,
                    name: itemName,
                    icon: itemIconPath, // Use 'icon' as expected by the helper
                    quantity: itemInfo.quantity
                };
                // --- END NEW ---

                if (!itemElement) {
                    // --- MODIFIED: Use helper to create the base element ---
                    itemElement = createInventoryItemElement(tempItemForHelper, true); // true for trade view
                    itemElement.id = itemElementId;
                    itemElement.className = 'trade-item trade-item-offered trade-item-yours'; // Set specific classes
                    itemElement.dataset.itemId = itemId; // Ensure dataset is set
                    // --- END MODIFIED ---

                    // --- MODIFIED: Add Click Listener for Removing Item from YOUR Offer ---
                    itemElement.addEventListener('click', function() {
                        if (!isTradeActive || !currentTradeSessionId) {
                            logTradeMessage("Not in an active trade session.", 'warn');
                            return;
                        }

                        const itemIdToRemove = this.dataset.itemId;
                        const itemNameForLog = itemName; // Capture name from closure or find it again
                        // Get current displayed quantity
                        const quantitySpan = this.querySelector('.item-quantity');
                        const currentOfferedQuantity = quantitySpan ? parseInt(quantitySpan.textContent.replace('x', ''), 10) || 1 : 1;

                        let quantityStr = prompt(`How many ${itemNameForLog} do you want to remove from trade? (Max: ${currentOfferedQuantity})`, currentOfferedQuantity.toString());
                        let quantityToRemove = parseInt(quantityStr, 10);

                        if (isNaN(quantityToRemove) || quantityToRemove <= 0) {
                            logTradeMessage("Invalid quantity entered for removal.", 'warn');
                            return;
                        }

                        if (quantityToRemove > currentOfferedQuantity) {
                            quantityToRemove = currentOfferedQuantity;
                            logTradeMessage(`Removal quantity capped to offered amount: ${quantityToRemove}`, 'info');
                        }

                        sendMessage({
                            type: "trade",
                            trade_action: "remove_item",
                            session_id: currentTradeSessionId,
                            item_id: itemIdToRemove,
                            quantity: quantityToRemove
                        });
                        logTradeMessage(`Attempting to remove ${quantityToRemove}x ${itemNameForLog} from trade.`, 'info');
                        // UI update will happen on server confirmation via handleTradeStatus 'item_removed'
                    });
                    // --- END MODIFIED ---

                    offerGrid.appendChild(itemElement);
                } else {
                    // Update existing element's quantity
                    const quantitySpan = itemElement.querySelector('.item-quantity');
                    if (quantitySpan) {
                        // Server sends new_total_quantity, so we set it directly
                        quantitySpan.textContent = `x${itemInfo.quantity}`;
                    }
                    // Icon and name should be correct from creation, no need to update here unless server sends new data
                }
            } else { // Removing
                if (itemElement) {
                    const quantitySpan = itemElement.querySelector('.item-quantity');
                    let currentQuantity = 0;
                    if (quantitySpan) {
                        currentQuantity = parseInt(quantitySpan.textContent.replace('x', ''), 10) || 0;
                    }
                    // --- MODIFIED: Handle quantity removed vs. quantity remaining ---
                    // Server sends the quantity removed. Calculate new quantity.
                    const quantityRemoved = itemInfo.quantity || 1; // This is the quantity removed
                    const newQuantity = currentQuantity - quantityRemoved;
                    // --- END MODIFIED ---

                    if (newQuantity <= 0) {
                        // Remove element entirely
                        itemElement.remove();
                    } else {
                        // Update quantity to the new calculated total
                        if (quantitySpan) {
                            quantitySpan.textContent = `x${newQuantity}`;
                        }
                    }
                }
                // If itemElement doesn't exist, it might have already been removed.
            }
        }

        // Helper function to manage partner's offer display
        function updatePartnerOfferDisplay(itemInfo, isAdding) {
            const offerGrid = document.getElementById('tradePartnerOffer');
            if (!offerGrid) {
                console.error("Partner offer grid element (#tradePartnerOffer) not found.");
                return;
            }

            const itemId = itemInfo.id;
            const itemElementId = `trade-partner-offer-item-${itemId}`;
            let itemElement = document.getElementById(itemElementId);

            if (isAdding) {
                // --- Find item details (name/icon) - server might send them, otherwise use defaults ---
                // This logic is similar to updateYourOfferDisplay
                let itemName = itemInfo.name;
                let itemIconPath = itemInfo.iconPath || itemInfo.icon; // Accept both keys from server message
                // If server doesn't send name/icon in trade_update, you might need to manage a separate
                // data structure for known item details or request full item data.
                // For now, assume server sends them or use defaults.
                itemName = itemName || itemId || 'Unknown Item';
                itemIconPath = itemIconPath || 'images/items/default-item.png';
                // --- End find item details ---

                // --- NEW: Use createInventoryItemElement helper ---
                // Create a temporary item object with the data we have for the helper
                const tempItemForHelper = {
                    id: itemId,
                    name: itemName,
                    icon: itemIconPath, // Use 'icon' as expected by the helper
                    quantity: itemInfo.quantity
                };
                // --- END NEW ---

                if (!itemElement) {
                    // --- MODIFIED: Use helper to create the base element ---
                    itemElement = createInventoryItemElement(tempItemForHelper, true); // true for trade view
                    itemElement.id = itemElementId;
                    itemElement.className = 'trade-item trade-item-offered trade-item-partner'; // Set specific classes
                    itemElement.dataset.itemId = itemId; // Ensure dataset is set
                    // Remove any click listener that might have been added by the helper for trade inventory
                    // by cloning without event listeners (or just don't add one)
                    // itemElement = itemElement.cloneNode(true); // This removes listeners but also ID/classes if not careful
                    // Better: Just don't add a listener here, or explicitly remove it if needed.
                    // Since we are setting className directly after, listeners from helper are likely gone anyway.
                    // --- END MODIFIED ---

                    // --- OPTIONAL: Add visual indication it's partner's item, maybe disable interaction ---
                    // The CSS class trade-item-partner should handle styling.
                    // itemElement.style.opacity = '0.8'; // Example: Slightly faded
                    // itemElement.style.cursor = 'default'; // Example: Not a pointer cursor
                    // Or rely on CSS class trade-item-partner for styling
                    // --- END OPTIONAL ---

                    offerGrid.appendChild(itemElement);
                } else {
                    // Update existing element's quantity
                    const quantitySpan = itemElement.querySelector('.item-quantity');
                    if (quantitySpan) {
                        // Assume server sends the new total quantity for partner updates too
                        // Check handleTradeUpdate logic: msg.quantity is sent for partner_item_added/removed
                        // For added: it's the quantity added (might need total if server sends delta)
                        // For removed: it's the quantity removed (we need to calculate new total)
                        // Based on the message structure you provided, it seems like for 'partner_item_removed',
                        // 'quantity' is the amount removed. Let's handle it consistently.
                        // Actually, looking at the standard pattern, server usually sends the NEW TOTAL for updates.
                        // Let's assume itemInfo.quantity IS the new total quantity to display.
                        // If the server sends the delta removed, we need to adjust handleTradeUpdate.
                        // For now, let's assume itemInfo.quantity is the correct total to display.
                        quantitySpan.textContent = `x${itemInfo.quantity}`;
                    }
                    // Icon and name should be correct from creation.
                }
            } else { // Removing (partner removed item)
                if (itemElement) {
                    const quantitySpan = itemElement.querySelector('.item-quantity');
                    let currentQuantity = 0;
                    if (quantitySpan) {
                        currentQuantity = parseInt(quantitySpan.textContent.replace('x', ''), 10) || 0;
                    }
                    // --- MODIFIED: Handle quantity removed vs. quantity remaining ---
                    // Server sends the quantity removed. Calculate new quantity.
                    const quantityRemoved = itemInfo.quantity || 1; // This is the quantity removed (from msg)
                    const newQuantity = currentQuantity - quantityRemoved;
                    // --- END MODIFIED ---

                    if (newQuantity <= 0) {
                        // Remove element entirely
                        itemElement.remove();
                    } else {
                        // Update quantity to the new calculated total
                        if (quantitySpan) {
                            quantitySpan.textContent = `x${newQuantity}`;
                        }
                    }
                }
                // If itemElement doesn't exist, it might have already been removed.
            }
        }

        // --- END NEW ---


        // --- NEW: Logging to Trade View ---
        function logTradeMessage(message, category = 'info') {
            const logDiv = document.getElementById('tradeMessages');
            if (!logDiv) return;

            const messageElement = document.createElement('div');
            messageElement.className = `trade-message trade-message-${category}`;
            // Simple formatting, consider using a library for richer logs
            const timestamp = new Date().toLocaleTimeString();
            messageElement.textContent = `[${timestamp}] ${message}`;

            logDiv.appendChild(messageElement);
            logDiv.scrollTop = logDiv.scrollHeight; // Auto-scroll to bottom
        }
        // --- END NEW ---


        // --- NEW: Event Listeners for Trade Actions ---
        document.addEventListener('DOMContentLoaded', function() {
            // ... (existing event listeners) ...

            // --- NEW: Trade Request Notification Buttons ---
            document.getElementById('acceptTradeRequest')?.addEventListener('click', function() {
                const notification = document.getElementById('tradeRequestNotification');
                // --- MODIFIED: Get the session ID from the notification element ---
                const sessionId = notification?.dataset?.sessionId; // Get stored Session ID
                const requesterId = notification?.dataset?.requesterId;
                // --- END MODIFIED ---
                // --- MODIFIED: Check sessionId in addition to requesterId ---
                if (requesterId && sessionId) { // Ensure both requester ID and Session ID are present
                    // --- MODIFIED: Include session_id in the message ---
                    sendMessage({
                        type: "trade",
                        trade_action: "response",
                        session_id: sessionId, // Include the Session ID
                        accepted: true
                    });
                    // --- END MODIFIED ---
                    hideTradeRequest(); // Hide notification immediately
                    logDebug("Trade request accepted.", 'info');
                } else {
                    // --- MODIFIED: Improved warning message ---
                    console.warn("Cannot accept trade: Missing requester ID or session ID.");
                    logDebug("Cannot accept trade: Missing requester ID or session ID.", 'error');
                    // --- END MODIFIED ---
                }
            });

            document.getElementById('declineTradeRequest')?.addEventListener('click', function() {
                const notification = document.getElementById('tradeRequestNotification');
                // --- MODIFIED: Get the session ID from the notification element ---
                const sessionId = notification?.dataset?.sessionId; // Get stored Session ID
                const requesterId = notification?.dataset?.requesterId;
                // --- END MODIFIED ---
                // --- MODIFIED: Check sessionId in addition to requesterId ---
                if (requesterId && sessionId) { // Ensure both requester ID and Session ID are present
                    // --- MODIFIED: Include session_id in the message ---
                    sendMessage({
                        type: "trade",
                        trade_action: "response",
                        session_id: sessionId, // Include the Session ID
                        accepted: false
                    });
                    // --- END MODIFIED ---
                    hideTradeRequest(); // Hide notification
                    logDebug("Trade request declined.", 'info');
                } else {
                    console.warn("Cannot decline trade: Missing requester ID or session ID.");
                    logDebug("Cannot decline trade: Missing requester ID or session ID.", 'error');
                }
            });
            // --- END NEW ---


            document.getElementById('tradeConfirm')?.addEventListener('click', function() {
                if (!isTradeActive || !currentTradeSessionId) {
                    logTradeMessage("Not in an active trade session.", 'warn');
                    return;
                }
                if (confirm("Are you sure you want to confirm this trade?")) {
                    sendMessage({
                        type: "trade",
                        trade_action: "confirm",
                        session_id: currentTradeSessionId // Include session ID
                    });
                    logTradeMessage("Trade confirmation sent.", 'info');
                }
            });

            document.getElementById('tradeCancel')?.addEventListener('click', function() {
                // Cancel can be sent regardless of confirmation state
                if (!isTradeActive && currentTradeSessionId === null) {
                    // If no trade view and no session, it might be a lingering request notification
                    hideTradeRequest();
                    logDebug("Trade request notification cleared.", 'info');
                    return;
                }
                if (confirm("Are you sure you want to cancel this trade?")) {
                    sendMessage({
                        type: "trade",
                        trade_action: "cancel" // Session ID might be needed, or server tracks it
                        // Include session ID if required by your server implementation
                        // session_id: currentTradeSessionId
                    });
                    logTradeMessage("Trade cancellation sent.", 'info');
                    // UI will be updated based on server's 'trade_status': 'cancelled' response
                }
            });
            // --- END NEW ---

        });
        // --- END NEW ---



        /* helper to send WS messages */
        function sendMessage(payload) {
            if (ws && ws.readyState === 1) ws.send(JSON.stringify(payload));
        }

        // --- Helper Function to Remove Enemy UI Element ---
        function removeEnemyFromCombatView(enemyId) {
            const enemyElement = document.querySelector(`#enemyListCombat .entity-card[data-entity-id="${enemyId}"]`);
            if (enemyElement) {
                // Optional: Add a fade-out animation class before removing
                enemyElement.classList.add('fade-out');
                setTimeout(() => enemyElement.remove(), 300); // Remove after animation
                enemyElement.remove();
                logDebug(`Removed enemy with ID ${enemyId} from UI.`, 'info');
            } else {
                console.warn(`Tried to remove enemy with ID ${enemyId}, but element not found in UI.`);
            }
        }

        // --- Mode Entry/Exit ---
        function enterCombatMode() {
            const combatPanel = document.getElementById('combatPanel');
            if (combatPanel) {
                combatPanel.style.display = 'block'; // Make panel visible FIRST
                console.log("Combat panel set to display: block"); // Debug log
            } else {
                console.error("enterCombatMode: Could not find #combatPanel element!");
                return; // Stop if panel doesn't exist
            }

            // showing this for debuggin purposes
            const statsDisplay = document.getElementById('playerStatsDisplay');
            if (statsDisplay) statsDisplay.style.display = 'block';

            // Ensure inventory panel is hidden initially when entering combat
            const inventoryPanel = document.getElementById('inventoryPanel');
            if (inventoryPanel) inventoryPanel.style.display = 'none';

            // Make sure the inventory button is visible (or add one to combat panel)
            const inventoryButton = document.getElementById('inventoryButton');
            if (inventoryButton) inventoryButton.style.display = 'block';

            // Clear previous state/logs
            clearCombatLog();

            // --- Correctly initialize combat log AFTER ensuring panel is visible ---
            // Force a reflow/repaint might help in some cases, but let's try direct access first.
            // Try accessing the element again after the panel is shown.
            const combatLogEntries = document.getElementById('combatLogEntries');
            if (combatLogEntries) {
                console.log("Found #combatLogEntries element after showing panel."); // Debug log
                // Clear it again just in case clearCombatLog affected it or there was old content
                combatLogEntries.innerHTML = '';
                // Add initial message to the inner container
                const initialEntry = document.createElement('div');
                initialEntry.className = 'combat-log-entry combat-log-system';
                initialEntry.textContent = 'Combat started!';
                combatLogEntries.appendChild(initialEntry);
                // Good practice to scroll:
                combatLogEntries.scrollTop = combatLogEntries.scrollHeight;
            } else {
                // If it's still not found, log a more detailed error
                console.error("enterCombatMode: Still could not find #combatLogEntries element after showing #combatPanel!");
                // Log the state of the parent
                const combatLogParent = document.getElementById('combatLog');
                console.log("#combatLog element:", combatLogParent);
                if (combatLogParent) {
                    console.log("#combatLog innerHTML:", combatLogParent.innerHTML);
                }
            }
            // --- End of Combat Log Initialization ---


            // Clear player/enemy lists if needed
            if (document.getElementById('playerListCombat')) document.getElementById('playerListCombat').innerHTML = '';
            if (document.getElementById('enemyListCombat')) document.getElementById('enemyListCombat').innerHTML = '';
            if (document.getElementById('availableActions')) document.getElementById('availableActions').innerHTML = '';

            isInCombat = true;
            logDebug("Entered combat mode.");
            // Wait for 'encounter_start' message to populate UI
        }

        function exitCombatMode() {
            document.getElementById('combatPanel').style.display = 'none';
            isInCombat = false;
            clearCombatLog();
            logDebug("Exited combat mode.");
            // Show other UI elements again if they were hidden
        }

        function updateCombatView(data) {
            console.log("Updating combat view with ", data); // Add this for debugging

            // This function updates the entire combat panel or parts of it based on data received
            if (data.players) {
                updatePlayerListCombat(data.players);
            }
            if (data.enemies) {
                updateEnemyListCombat(data.enemies);
            }
            if (data.currentTurnEntity) {
                highlightCurrentTurnEntity(data.currentTurnEntity); // Implement this
            }
            if (data.turnOrder) {
                // Update a turn order display if you have one
            }
            // Update other parts of the UI as needed based on the data structure
        }

        function updatePlayerListCombat(players) {
            const container = document.getElementById('playerListCombat');
            if (!container) return;

            container.innerHTML = ''; // Clear previous entries

            players.forEach(playerData => {
                // Create player element
                const playerEl = document.createElement('div');
                playerEl.className = `entity-card player ${playerData.id === currentPlayerId ? 'current-player' : ''}`;
                playerEl.dataset.entityType = 'player';
                playerEl.dataset.entityId = playerData.id;

                // --- Create Icon Container and Image ---
                const iconContainerEl = document.createElement('div');
                iconContainerEl.className = 'entity-icon-container';

                const iconImgEl = document.createElement('img');
                iconImgEl.className = 'entity-icon';
                iconImgEl.src = playerData.iconPath || 'images/players/default-player.png'; // Use received path or default
                iconImgEl.alt = `${playerData.name} Icon`; // Accessibility

                iconContainerEl.appendChild(iconImgEl);
                // --- End Icon Creation ---


                // Player Name
                const nameEl = document.createElement('div');
                nameEl.className = 'entity-name';
                nameEl.textContent = playerData.name || 'Unknown Player';

                // Player Stats (Level, Class etc. could go here)
                const statsEl = document.createElement('div');
                statsEl.className = 'entity-stats';
                statsEl.textContent = `Lv. ${playerData.level || 1}`; // Example stat

                // Actions Remaining
                const actionsEl = document.createElement('div');
                actionsEl.className = 'entity-actions';
                actionsEl.textContent = `Actions: ${playerData.actionsRemaining || 0}/${playerData.totalActions || 0}`;
                playerEl.appendChild(actionsEl);

                // HP Bar Container
                const hpBarEl = document.createElement('div');
                hpBarEl.className = 'hp-bar-container';

                // HP Bar Fill
                const hpFillEl = document.createElement('div');
                hpFillEl.className = 'hp-bar-fill';
                const hpPercent = (playerData.currentHealth / playerData.maxHealth) * 100;
                hpFillEl.style.width = `${hpPercent}%`;
                if (hpPercent < 30) {
                    hpFillEl.classList.add('low');
                }

                // HP Text
                const hpTextEl = document.createElement('div');
                hpTextEl.className = 'hp-text';
                hpTextEl.textContent = `${playerData.currentHealth}/${playerData.maxHealth} HP`;

                // Assemble Player Element
                playerEl.appendChild(iconContainerEl);
                hpBarEl.appendChild(hpFillEl);
                playerEl.appendChild(nameEl);
                playerEl.appendChild(statsEl);
                playerEl.appendChild(hpBarEl);
                playerEl.appendChild(hpTextEl);

                // Add click handler for target selection
                playerEl.addEventListener('click', () => selectTarget(playerEl));

                container.appendChild(playerEl);
            });
        }

        function updateEnemyListCombat(enemies) {
            const container = document.getElementById('enemyListCombat');
            if (!container) return;

            container.innerHTML = ''; // Clear previous entries

            enemies.forEach(enemyData => {
                // Create enemy element
                const enemyEl = document.createElement('div');
                enemyEl.className = 'entity-card enemy';
                enemyEl.dataset.entityType = 'enemy';
                enemyEl.dataset.entityId = enemyData.id; // Assuming enemy has a unique ID

                // --- Create Icon Container and Image ---
                const iconContainerEl = document.createElement('div');
                iconContainerEl.className = 'entity-icon-container';

                const iconImgEl = document.createElement('img');
                iconImgEl.className = 'entity-icon';
                iconImgEl.src = enemyData.iconPath || 'images/enemies/default-enemy.png'; // Use received path or default
                iconImgEl.alt = `${enemyData.name} Icon`; // Accessibility

                iconContainerEl.appendChild(iconImgEl);
                // --- End Icon Creation ---

                // Enemy Name
                const nameEl = document.createElement('div');
                nameEl.className = 'entity-name';
                nameEl.textContent = enemyData.name || 'Unknown Enemy';

                // Enemy Stats (Type, etc. could go here)
                const statsEl = document.createElement('div');
                statsEl.className = 'entity-stats';
                // statsEl.textContent = `Type: ${enemyData.type || 'Normal'}`; // Example

                // HP Bar Container
                const hpBarEl = document.createElement('div');
                hpBarEl.className = 'hp-bar-container';

                // HP Bar Fill
                const hpFillEl = document.createElement('div');
                hpFillEl.className = 'hp-bar-fill';
                const hpPercent = (enemyData.currentHealth / enemyData.maxHealth) * 100;
                hpFillEl.style.width = `${hpPercent}%`;
                if (hpPercent < 30) {
                    hpFillEl.classList.add('low');
                }

                // HP Text
                const hpTextEl = document.createElement('div');
                hpTextEl.className = 'hp-text';
                hpTextEl.textContent = `${enemyData.currentHealth}/${enemyData.maxHealth} HP`;

                // Assemble Enemy Element
                enemyEl.appendChild(iconContainerEl); // <-- Add Icon Container
                hpBarEl.appendChild(hpFillEl);
                enemyEl.appendChild(nameEl);
                enemyEl.appendChild(statsEl);
                enemyEl.appendChild(hpBarEl);
                enemyEl.appendChild(hpTextEl);

                // Add click handler for target selection
                enemyEl.addEventListener('click', () => selectTarget(enemyEl));

                container.appendChild(enemyEl);
            });
        }

        function highlightCurrentTurnEntity(entityInfo) {
            // Remove highlight from all player and enemy entries first
            const playerEntries = document.querySelectorAll('#playerListCombat > .entity-card');
            const enemyEntries = document.querySelectorAll('#enemyListCombat > .entity-card');
            playerEntries.forEach(el => el.classList.remove('current-turn'));
            enemyEntries.forEach(el => el.classList.remove('current-turn'));

            // Find and highlight the correct entry
            let targetElement = null;
            if (entityInfo.type === 'player') {
                targetElement = document.querySelector(`#playerListCombat .entity-card[data-entity-id="${entityInfo.id}"]`);
            } else if (entityInfo.type === 'enemy') {
                targetElement = document.querySelector(`#enemyListCombat .entity-card[data-entity-id="${entityInfo.id}"]`);
            }

            if (targetElement) {
                targetElement.classList.add('current-turn');
                logDebug(`It's ${entityInfo.name}'s turn (${entityInfo.type}).`);
                
                // If it's the current player's turn, enable action buttons
                if (entityInfo.type === 'player' && entityInfo.id === currentPlayerId) {
                    updateActionButtons(entityInfo.name);
                } else {
                    // Disable or clear actions for other players/enemies
                    document.getElementById('availableActions').innerHTML = '<div class="log-entry info">Waiting for your turn...</div>';
                }
            } else {
                console.warn("Could not find entity to highlight for turn:", entityInfo);
            }
        }

        function updateActionButtons(currentEntityName) {
            const actionContainer = document.getElementById('availableActions');
            if (!actionContainer) {
                console.error("updateActionButtons: Could not find #availableActions element.");
                return;
            }
            actionContainer.innerHTML = ''; // Clear previous actions

            // --- Safety Check: Ensure playerStats.abilities exists and is an array ---
            if (!Array.isArray(playerStats.abilities)) {
                console.warn("updateActionButtons: playerStats.abilities is not an array or is undefined.", playerStats.abilities);
                // You might want to display a message in the UI here
                const errorMsg = document.createElement('div');
                errorMsg.className = 'log-entry error';
                errorMsg.textContent = 'Error loading abilities.';
                actionContainer.appendChild(errorMsg);
                // Still add basic actions/end turn?
            }

            // --- 1. Use Ability ---
            // Iterate through the abilities received from the server
            if (Array.isArray(playerStats.abilities)) {
                playerStats.abilities.forEach(ability => {
                    // Basic validation
                    if (!ability || !ability.id) {
                        console.warn("Skipping invalid ability data:", ability);
                        return; // Skip this iteration
                    }

                    const abilityBtn = document.createElement('button');
                    abilityBtn.className = 'action-btn ability-btn';
                    abilityBtn.dataset.abilityId = ability.id;
                    
                    // Create container for icon and text
                    const btnContent = document.createElement('div');
                    btnContent.className = 'ability-btn-content';
                    
                    // Add icon if available
                    if (ability.iconPath) {
                        const iconEl = document.createElement('img');
                        iconEl.className = 'ability-icon';
                        iconEl.src = ability.iconPath;
                        iconEl.alt = ability.name;
                        iconEl.onerror = function() {
                            // Fallback if icon fails to load
                            this.src = 'images/icons/default-ability.png';
                        };
                        btnContent.appendChild(iconEl);
                    }
                    
                    // Add ability name and cost
                    const textEl = document.createElement('span');
                    textEl.className = 'ability-text';
                    let buttonText = ability.name;
                    if (ability.actionCost !== undefined && ability.actionCost > 0) {
                        buttonText += ` (${ability.actionCost} AP)`;
                    }
                    textEl.textContent = buttonText;
                    btnContent.appendChild(textEl);
                    
                    abilityBtn.appendChild(btnContent);
                    
                    // Tooltip with target types
                    if (Array.isArray(ability.targetTypes) && ability.targetTypes.length > 0) {
                        abilityBtn.title = `Targets: ${ability.targetTypes.join(', ')}`;
                    } else {
                        abilityBtn.title = `Targets: Unknown`;
                    }                
                    // Just graying out button if not enough total actions. Server will still handle validation!
                    const actionCost = ability.actionCost || 1;
                    if (playerStats.totalActions < actionCost) {
                        abilityBtn.classList.add('unaffordable');
                    } else {
                        abilityBtn.classList.remove('unaffordable');
                    }
                    
                    abilityBtn.onclick = () => initiateAction('use_ability', { abilityId: ability.id });
                    
                    actionContainer.appendChild(abilityBtn);
                });
            }

            // --- 4. End Turn Button (Optional but Standard) ---
            const endTurnBtn = document.createElement('button');
            endTurnBtn.className = 'action-btn end-turn';
            endTurnBtn.textContent = 'End Turn';
            endTurnBtn.onclick = () => sendCombatAction('end_turn');
            actionContainer.appendChild(endTurnBtn);
        }
        function initiateAction(actionType, details = {}) {
            selectedAction = { type: actionType, details: details };
            
            // Check if action requires a target
            const needsTarget = (actionType === 'use_ability');

            if (needsTarget) {
                document.getElementById('targetSelectionPrompt').style.display = 'block';
                logDebug("Please select a target for your action.", 'warning');
                // Visually indicate that entities are selectable
                // This is handled by the .entity-card:hover and .selected-target CSS
            } else {
                // Action doesn't need a target, send immediately
                sendCombatAction(selectedAction.type, selectedAction.details);
                resetActionSelection();
            }
        }

        function selectTarget(targetElement) {
             // Only proceed if an action requiring a target has been selected
            if (!selectedAction) {
                logDebug("Please select an action first.", 'warning');
                return;
            }

            // Clear previous target selection highlight
            document.querySelectorAll('.entity-card').forEach(el => el.classList.remove('selected-target'));

            // Highlight the selected target
            targetElement.classList.add('selected-target');
            
            // Store the selected target's info
            const targetType = targetElement.dataset.entityType;
            const targetId = targetElement.dataset.entityId;
            selectedTarget = { type: targetType, id: targetId };

            // --- CORRECTED: Format target specifier as expected by server ---
            // Option 1: Combined string like "enemy_-22160"
            const targetSpecifier = `${targetType}_${targetId}`;
            // --- END CORRECTION ---

            // Add target to action details
            const actionDetailsWithTarget = { ...selectedAction.details, target: targetSpecifier};

            // Send the complete action
            sendCombatAction(selectedAction.type, actionDetailsWithTarget);
            
            // Reset selection state
            resetActionSelection();
        }

        function resetActionSelection() {
            selectedAction = null;
            selectedTarget = null;
            document.getElementById('targetSelectionPrompt').style.display = 'none';
            document.querySelectorAll('.entity-card').forEach(el => el.classList.remove('selected-target'));
        }

        function sendCombatAction(actionType, details = {}) {
            // Send the player's chosen action to the server

            if (!isInCombat || !currentPlayerId) {
                logDebug("Cannot send action: Not in combat or player ID unknown.");
                return;
            }
            const actionMessage = {
                type: actionType, // Message type for PlayerManager->CombatService e.g., "melee_attack", "use_ability", "use_item"
                ...details // e.g., { abilityId: "fireball", target: "enemy_1" } or { itemId: "health_potion_01" }
            };
            sendMessage(actionMessage);
            logCombatMessage(`You used ${actionType}.`, "player");
        }


        function logCombatMessage(message, category = "system") {
            // Target the inner container explicitly
            const logContainer = document.getElementById('combatLogEntries');
            if (!logContainer) {
                console.error("logCombatMessage: Combat log container (#combatLogEntries) not found!");
                // Fallback to console if UI element is missing or hidden
                console.log(`[Combat Log Fallback - ${category}]: ${message}`);
                return;
            }
            const entryEl = document.createElement('div');
            // Validate category
            const validCategories = ['player', 'enemy', 'system', 'damage', 'heal', 'info', 'warning', 'error', 'success'];
            const logCategory = validCategories.includes(category) ? category : 'system';
            entryEl.className = `combat-log-entry combat-log-${logCategory}`;
            entryEl.textContent = `[${new Date().toLocaleTimeString()}] ${message}`;
            logContainer.appendChild(entryEl);

            // --- Ensure Auto-Scroll ---
            // Simply set scrollTop to scrollHeight. The CSS change should make this work.
            logContainer.scrollTop = logContainer.scrollHeight;
            // --- End Auto-Scroll ---
        }

        function clearCombatLog() {
            // Target the inner container that holds the entries, not the parent container
            const logEntriesElement = document.getElementById('combatLogEntries');
            if (logEntriesElement) {
                // Clear only the contents of the entries container
                logEntriesElement.innerHTML = '';
            } else {
                // Fallback: if #combatLogEntries is missing for some reason, clear #combatLog
                // This might be needed if clearCombatLog is called before enterCombatMode
                // sets up the structure correctly, though ideally that shouldn't happen now.
                console.warn("clearCombatLog: #combatLogEntries not found. Clearing #combatLog instead.");
                const logElement = document.getElementById('combatLog');
                if (logElement) {
                    logElement.innerHTML = '';
                }
            }
        }

        // --- Helper Function to Update a Specific Entity's Stats in the UI ---
        function updateCombatantStats(entityData) {
            // entityData should contain at least { id, type, currentHealth, maxHealth }
            // type is needed to know which list to look in (player or enemy)
            const entityId = entityData.id;
            const entityType = entityData.type;

            let targetContainerId, entitySelector;
            if (entityType === 'player') {
                targetContainerId = 'playerListCombat';
                entitySelector = '.entity-card.player'; // Be specific to player cards
            } else if (entityType === 'enemy') {
                targetContainerId = 'enemyListCombat';
                entitySelector = '.entity-card.enemy'; // Be specific to enemy cards
            } else {
                console.warn("updateCombatantStats: Unknown entity type:", entityType);
                return;
            }

            const entityElement = document.querySelector(`#${targetContainerId} ${entitySelector}[data-entity-id="${entityId}"]`);

            if (entityElement) {
                // Update HP Text
                const hpTextElement = entityElement.querySelector('.hp-text');
                if (hpTextElement && entityData.hasOwnProperty('currentHealth') && entityData.hasOwnProperty('maxHealth')) {
                    hpTextElement.textContent = `${entityData.currentHealth}/${entityData.maxHealth} HP`;
                }

                // Update HP Bar
                const hpBarFillElement = entityElement.querySelector('.hp-bar-fill');
                if (hpBarFillElement && entityData.hasOwnProperty('currentHealth') && entityData.hasOwnProperty('maxHealth')) {
                    const hpPercent = (entityData.currentHealth / entityData.maxHealth) * 100;
                    hpBarFillElement.style.width = `${hpPercent}%`;
                    
                    // Update color based on health (like in initial render)
                    hpBarFillElement.classList.remove('low'); // Reset class
                    if (hpPercent < 30) {
                        hpBarFillElement.classList.add('low');
                    }
                }

                // Update Actions (if displayed)
                // If you show actions remaining, find that element and update it similarly
                // Example (if you have an element with class 'actions-text'):
                /*
                const actionsTextElement = entityElement.querySelector('.actions-text');
                if (actionsTextElement && entityData.hasOwnProperty('actions')) {
                    actionsTextElement.textContent = `Actions: ${entityData.actions}`;
                }
                */

                // Handle Death State (Optional Visual)
                if (entityData.hasOwnProperty('currentHealth') && entityData.currentHealth <= 0) {
                    // Add a visual indicator for defeated entities
                    entityElement.classList.add('defeated');
                    // You could also grey out the card, add a skull icon, etc.
                    const nameElement = entityElement.querySelector('.entity-name');
                    if (nameElement) {
                        nameElement.textContent = nameElement.textContent + " (Defeated)";
                    }
                } else {
                    // Ensure defeated class is removed if entity is healed above 0
                    entityElement.classList.remove('defeated');
                    const nameElement = entityElement.querySelector('.entity-name');
                    if (nameElement && nameElement.textContent.includes(" (Defeated)")) {
                        nameElement.textContent = nameElement.textContent.replace(" (Defeated)", "");
                    }
                }

                console.log(`Updated stats for ${entityType} ${entityId}`);
            } else {
                // This might happen if an update arrives for an entity that hasn't been fully rendered yet,
                // or if the ID is incorrect. Log it for debugging.
                console.warn(`updateCombatantStats: Could not find UI element for ${entityType} with ID ${entityId}`);
                // Optional: If it's an enemy, maybe it was just defeated and removed? Check msg.type.
            }
        }


        function updatePlayerList(players) {
            const listElement = document.getElementById('playerList');
            listElement.innerHTML = '';
            
            players.forEach(player => {
                const entry = document.createElement('div');
                entry.className = `player-entry ${player.IsReady ? 'ready' : ''}`;
                
                const playerInfo = document.createElement('div');
                playerInfo.className = 'player-info';
                playerInfo.innerHTML = `
                    <span><b>${player.Name}</b></span>
                    <span>${player.Role}</span>
                    <span>${player.IsReady ? 'READY' : 'waiting'}</span>
                `;
                
                entry.appendChild(playerInfo);
                listElement.appendChild(entry);
            });
        }

        function toggleReady() {
            isReady = !isReady;
            const message = {
                type: "set_ready",
                isReady: isReady
            };
            console.log("Sending ready message:", message);
            ws.send(JSON.stringify(message));
            document.getElementById('readyButton').textContent = isReady ? "Unready" : "Ready Up";
            logDebug(`Set ready state to ${isReady}`);
        }

        function startGame() {
            ws.send(JSON.stringify({ type: "start_game" }));
            logDebug("Sent start game request");
        }

        function disconnect() {
            if (ws) {
                logDebug("Disconnecting...");
                ws.close();
            }
        }

        debugInterval = setInterval(() => {
            if (ws) {
                // switching debugging to console to prevent clutter in client log
                //logDebug(`Connection state: ${ws.readyState}`);
                console.log("WebSocket Connection state:", ws.readyState);
            }
        }, 5000);
    </script>
</body>
</html>