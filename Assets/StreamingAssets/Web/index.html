<!DOCTYPE html>
<html>
<head>
    <title>Game Lobby</title>
    <link rel="stylesheet" type="text/css" href="styles.css">
</head>
<body onload="populateClassList()">
    <div id="joinView">
        <h2>Join Game</h2>
        <div class="input-group">
            <label>Room Code:</label>
            <input type="text" id="roomCodeInput" placeholder="Enter room code">
        </div>
        <div class="input-group">
            <label>Your Name:</label>
            <input type="text" id="nameInput" placeholder="Your player name">
        </div>
        <div class="input-group">
            <label>Class:</label>
            <select id="classSelect">
            </select>
        </div>

        <button onclick="joinGame()">Join Game</button>
    </div>

    <div id="lobbyView">
        <h2>Room: <span id="roomCodeDisplay"></span></h2>
        <div id="playerList"></div>
        <button id="readyButton" onclick="toggleReady()">Ready Up</button>
        <button id="startButton" onclick="startGame()" disabled>Start Game</button>
        <button onclick="disconnect()">Leave Lobby</button>
    </div>
    <div id="gameView">
        <!-- Inventory Button (floating action button for mobile) -->
        <button id="inventoryButton" class="fab">
            <img src="images/icons/backpack.jpg" alt="Inventory">
        </button>

        <!-- Player Stats Display -->
        <div id="playerStatsDisplay" class="stats-display">
            <h3 id="statsPlayerName">Player Name</h3>
            <p><strong>Class:</strong> <span id="statsPlayerClass">-</span></p>
            <p><strong>Level:</strong> <span id="statsPlayerLevel">-</span></p>
            <p><strong>XP:</strong> <span id="statsPlayerExperience">0</span></p>
            <p><strong>HP:</strong> <span id="statsCurrentHealth">0</span>/<span id="statsMaxHealth">0</span></p>
            <p><strong>ATK:</strong> <span id="statsAttack">0</span></p>
            <p><strong>DEF:</strong> <span id="statsDefense">0</span></p>
            <p><strong>MAG:</strong> <span id="statsMagic">0</span></p>
        </div>
        
        <!-- Combat View Panel -->
        <div id="combatPanel" style="display:none;"> <!-- Start hidden -->
            <div id="combatHeader">
                <h2>Combat</h2>
                <div id="combatStatus">Encounter Starting...</div>
            </div>

            <div id="combatParticipants">
                <div id="playerParty">
                    <h3>Party</h3>
                    <div id="playerListCombat">
                        <!-- Player status will be populated here by JS -->
                        <!--
                        <div class="combatant player">
                            <span class="combatant-name">PlayerName</span>
                            <div class="hp-bar">
                                <div class="hp-fill" style="width: 70%;"></div>
                                <span class="hp-text">70/100</span>
                            </div>
                        </div>
                        -->
                    </div>
                </div>
                <div id="enemyParty">
                    <h3>Enemies</h3>
                    <div id="enemyListCombat">
                        <!-- Enemy status will be populated here by JS -->
                    </div>
                </div>
            </div>

            <div id="combatActions">
                <h3>Actions</h3>
                <div id="availableActions">
                    <!-- Actions will be populated here by JS based on player's turn and available abilities/items -->
                    <!-- Example structure:
                    <button class="combat-action-btn" data-action="melee_attack">Melee Attack</button>
                    <button class="combat-action-btn" data-action="use_ability" data-ability-id="fireball">Fireball</button>
                    <button class="combat-action-btn" data-action="use_item" data-item-id="health_potion_01">Use Potion</button>
                    -->
                </div>
            </div>

            <div id="combatLog">
                <h3>Log</h3>
                <div id="combatLogEntries">
                    <!-- Combat messages will appear here -->
                </div>
            </div>
        </div>


        <!-- Inventory Panel -->
        <div id="inventoryPanel">
            <div class="inventory-header">
                <h3>Inventory</h3>
                <button id="closeInventory">X</button>
            </div>
            <div id="equippedSection">
                <h4>Equipped</h4>
                <div id="equippedItems" class="equipped-grid">
                    <!-- Equipped items will be populated here -->
                    <!-- Example slot placeholders (optional) -->
                    <!--
                    <div class="equipped-slot" data-slot="Weapon"><span class="slot-name">Weapon</span></div>
                    <div class="equipped-slot" data-slot="Armor"><span class="slot-name">Armor</span></div>
                    <div class="equipped-slot" data-slot="Accessory"><span class="slot-name">Accessory</span></div>
                    -->
                </div>
            </div>
            <hr> <!-- Separator -->
            <div id="bagSection">
                <h4>Bag</h4>
                <div id="inventoryItems" class="inventory-grid">
                    <!-- Bag items will be populated here -->
                </div>
            </div>
        </div>
    </div>
    <div id="debugLog">Connecting...</div>

    <script>
        let ws;
        let currentPlayerId;
        let isReady = false;
        let debugInterval;
        let roomCode = '';

        let isInCombat = false;
        let currentCombatState = null; // To store data sent by the server

        /* ---- INVENTORY UI ---- */
        const inventoryButton = document.getElementById('inventoryButton');
        const inventoryPanel   = document.getElementById('inventoryPanel');
        const closeInventory   = document.getElementById('closeInventory');
        const inventoryItems   = document.getElementById('inventoryItems');
        let inventoryData      = [];

        /* ---- STAT UI CONST ---- */
        let playerStats = {
            // Initialize with default/empty values
            name: "Player Name",
            class: "-",
            level: 1,
            experience: 0, // Add experience property
            currentHealth: 0,
            maxHealth: 0,
            attack: 0,
            defense: 0,
            magic: 0
        };

        // --- helper function to update the stats display ---
        function updateStatsDisplay() {
            if (!playerStats) return; // Don't update if no stats yet

            document.getElementById('statsPlayerName').textContent = playerStats.name || "Unknown";
            document.getElementById('statsPlayerClass').textContent = playerStats.class || "-";
            document.getElementById('statsPlayerLevel').textContent = playerStats.level !== undefined ? playerStats.level : "-"; // Update level
            document.getElementById('statsPlayerExperience').textContent = playerStats.experience !== undefined ? playerStats.experience : "0"; // Update XP display
            document.getElementById('statsCurrentHealth').textContent = playerStats.currentHealth !== undefined ? playerStats.currentHealth : "0";
            document.getElementById('statsMaxHealth').textContent = playerStats.maxHealth !== undefined ? playerStats.maxHealth : "0";
            document.getElementById('statsAttack').textContent = playerStats.attack !== undefined ? playerStats.attack : "0";
            document.getElementById('statsDefense').textContent = playerStats.defense !== undefined ? playerStats.defense : "0";
            document.getElementById('statsMagic').textContent = playerStats.magic !== undefined ? playerStats.magic : "0";

            // Optional: Add visual feedback for low health
            const healthPercent = playerStats.maxHealth > 0 ? (playerStats.currentHealth / playerStats.maxHealth) : 0;
            const statsDisplay = document.getElementById('playerStatsDisplay');
            statsDisplay.classList.remove('low-health'); // Remove class first
            if (healthPercent < 0.3) { // Example: Red if below 30%
                statsDisplay.classList.add('low-health');
            }
        }





        // --- Ensure your existing toggleInventory function requests the full update ---
        function toggleInventory() {
            const panel = document.getElementById('inventoryPanel');
            const statsDisplay = document.getElementById('playerStatsDisplay'); // <-- Get stats display
            const isVisible = panel.style.display === 'block';
            panel.style.display = isVisible ? 'none' : 'block';

            // Adjust stats display visibility based on context
            if (statsDisplay) {
                if (isVisible) {
                    // Inventory closing
                    if (isInCombat) {
                        // Keep stats hidden in combat, or show combat-specific stats
                        statsDisplay.style.display = 'none';
                    } else {
                        // Show main stats outside combat
                        statsDisplay.style.display = 'block';
                    }
                } else {
                    // Inventory opening, hide stats in both cases probably
                    statsDisplay.style.display = 'none';
                }
            }

            // In combat, maybe also hide/show action buttons?
            const actionsDiv = document.getElementById('availableActions');
            if (actionsDiv && isInCombat) {
                actionsDiv.style.display = isVisible ? 'block' : 'none'; // Hide actions when inv open
            }

            if (!isVisible) { // If we are opening the panel
                sendMessage({ type: "inventory", action: "get" }); // Request full inventory data
            }
        }

        // Proper event listeners
        document.getElementById('inventoryButton').addEventListener('click', function(e) {
            e.preventDefault();
            toggleInventory();
        });

        document.getElementById('closeInventory').addEventListener('click', function(e) {
            e.preventDefault();
            toggleInventory();
        });

        // Handle clicks outside inventory content
        document.getElementById('inventoryPanel').addEventListener('click', function(e) {
            if (e.target === this) { // Clicked on backdrop
                toggleInventory();
            }
        });

        function handleInventoryData(inventoryUpdateData) {
            // --- Handle Bag Items (existing logic, slightly modified) ---
            const bagItems = inventoryUpdateData.items || []; // Ensure it's an array
            const bagContainer = document.getElementById('inventoryItems');
            bagContainer.innerHTML = ''; // Clear existing items

            if (bagItems.length === 0) {
                bagContainer.innerHTML = '<div class="empty-inventory">Your bag is empty</div>';
            } else {
                bagItems.forEach(item => {
                    const itemEl = createInventoryItemElement(item); // Reuse item creation logic
                    // Add click listener for using items from the bag
                    itemEl.addEventListener('click', () => {
                        sendMessage({ type: "inventory", action: "use", itemId: item.id });
                    });
                    bagContainer.appendChild(itemEl);
                });
            }

            // --- Handle Equipped Items (NEW LOGIC) ---
            const equippedData = inventoryUpdateData.equipped || {}; // Ensure it's an object
            const equippedContainer = document.getElementById('equippedItems');
            equippedContainer.innerHTML = ''; // Clear existing slots/items

            // Define your expected equipment slots (order matters for display)
            // Make sure these match the enum names used in C# (ItemDefinition.EquipmentSlot)
            const equipmentSlotOrder = ['MainHand', 'OffHand', 'Head', 'Body', 'Accessory'];

            equipmentSlotOrder.forEach(slotName => {
                const itemData = equippedData[slotName]; // Get item data for this slot, if any

                // Create a container for the slot
                const slotEl = document.createElement('div');
                slotEl.className = 'equipped-slot'; // Base class for styling
                slotEl.dataset.slot = slotName; // Store slot name for potential future use

                if (itemData) {
                    // Slot is filled
                    slotEl.classList.add('filled');

                    // Create the equipped item element (similar to bag item)
                    const equippedItemEl = createInventoryItemElement(itemData);

                    // Optional: Add specific class or behavior for equipped items
                    equippedItemEl.classList.add('equipped-item');

                    // Add click listener to potentially unequip or show details
                    // Here, we'll use the "equip" action, which should toggle it off
                    // according to your C# logic (PlayerInventory.EquipItem)
                    equippedItemEl.addEventListener('click', () => {
                        sendMessage({ type: "inventory", action: "use", itemId: itemData.id });
                        // Or send "use" if that's the intended way to toggle equipment
                        // sendMessage({ type: "inventory", action: "use", itemId: itemData.id });
                    });

                    // Clear default content and add the item
                    slotEl.innerHTML = '';
                    slotEl.appendChild(equippedItemEl);

                } else {
                    // Slot is empty
                    // Display the slot name or an empty indicator
                    const slotNameEl = document.createElement('span');
                    slotNameEl.className = 'slot-name';
                    slotNameEl.textContent = slotName;
                    slotEl.appendChild(slotNameEl);
                    // You might add a visual "empty slot" icon here too if desired
                }

                equippedContainer.appendChild(slotEl);
            });

            // --- Show the inventory panel if it's not already visible ---
            // (This part was already handled by toggleInventory calling this function)
        }
        // --- Helper function to create an inventory item element ---
        // This avoids duplicating the creation logic for bag and equipped items
        function createInventoryItemElement(item) {
            const itemEl = document.createElement('div');
            itemEl.className = 'inventory-item'; // Or 'equipped-item' if you want different base styles

            // --- Create the image element ---
            const imgEl = document.createElement('img');
            imgEl.alt = item.name || 'Item';
            imgEl.className = 'item-icon';

            // --- Implement PNG/JPG fallback logic ---
            let basePath = item.icon || 'images/icons/default-item.jpg';
            if (basePath === 'images/icons/default-item.jpg') {
                imgEl.src = basePath;
            } else {
                imgEl.src = `${basePath}.png`;
                imgEl.onerror = function () {
                    console.warn(`Failed to load PNG icon: ${this.src}. Trying JPG...`);
                    this.src = `${basePath}.jpg`;
                    this.onerror = function () {
                        console.warn(`Failed to load JPG icon: ${this.src}. Loading default.`);
                        this.src = 'images/icons/default-item.jpg';
                    };
                };
            }

            // --- Create name element ---
            const nameEl = document.createElement('span');
            nameEl.className = 'item-name';
            nameEl.textContent = item.name || 'Unknown Item';

            // --- Create quantity element (if applicable and > 1) ---
            let quantityEl = null;
            if (item.quantity && item.quantity > 1) {
                quantityEl = document.createElement('span');
                quantityEl.className = 'item-quantity';
                quantityEl.textContent = item.quantity;
            }

            // --- Assemble the item element ---
            itemEl.appendChild(imgEl);
            itemEl.appendChild(nameEl);
            if (quantityEl) {
                itemEl.appendChild(quantityEl);
            }

            return itemEl;
        }
        /* ---- INVENTORY UI END---- */

        function logDebug(message) {
            const debugElement = document.getElementById('debugLog');
            debugElement.innerHTML += `${new Date().toLocaleTimeString()}: ${message}<br>`;
            debugElement.scrollTop = debugElement.scrollHeight;
        }

        function populateClassList() {
            fetch('/api/classes')
                .then(r => r.json())
                .then(classes => {
                    const sel = document.getElementById('classSelect');
                    sel.innerHTML = '';
                    classes.forEach(c => {
                        const opt = document.createElement('option');
                        opt.value = c.className;
                        opt.textContent = c.className;
                        opt.dataset.icon = c.iconPath;  // Store the icon path if needed
                        sel.appendChild(opt);
                    });
                    logDebug(`Loaded ${classes.length} classes`);
                })
                .catch(err => logDebug(`Failed to load classes: ${err}`));
        }

        function joinGame() {
            roomCode = document.getElementById('roomCodeInput').value.trim();
            const name = document.getElementById('nameInput').value.trim();
            const className = document.getElementById('classSelect').value;

            if (!roomCode || !name) {
                logDebug("Please enter room code and name");
                return alert("Please enter room code and name");
            }

            logDebug(`Connecting to room ${roomCode} as ${name} (${className})...`);
            
            ws = new WebSocket(`ws://${window.location.hostname}:9000/game`);

            ws.onopen = () => {
                ws.send(JSON.stringify({
                    type: "join",
                    roomCode: roomCode,
                    name: name,
                    class: className 
                }));
            };

            ws.onmessage = (e) => {
                const msg = JSON.parse(e.data);
                handleServerMessage(msg);
            };

            ws.onclose = () => {
                logDebug("Disconnected from server");
                document.getElementById('joinView').style.display = 'block';
                document.getElementById('lobbyView').style.display = 'none';
                document.getElementById('gameView').style.display = 'none'; 

            };

            ws.onerror = (err) => {
                logDebug(`WebSocket error: ${err.message}`);
            };
        }

        function handleServerMessage(msg) {
            switch(msg.type) {
                case "join_success":
                    currentPlayerId = msg.playerId;
                    document.getElementById('roomCodeDisplay').textContent = roomCode;
                    document.getElementById('joinView').style.display = 'none';
                    document.getElementById('lobbyView').style.display = 'block';
                    playerStats.name = msg.profile.name;
                    logDebug(`Joined successfully as ${msg.profile.name}`);
                    break;
                    
                case "join_error":
                    logDebug(`Join failed: ${msg.message}`);
                    alert(msg.message);
                    break;
                    
                case "lobby_update":
                    updatePlayerList(msg.players);
                    document.getElementById('startButton').disabled = !msg.canStart;
                    logDebug(`Player list updated (${msg.players.length} players)`);
                    break;
                case "game_state_change":
                    switch (msg.state) {
                        case "Map":
                            exitCombatMode();
                            document.getElementById('lobbyView').style.display = 'none';
                            document.getElementById('gameView').style.display = 'block';
                            // Ensure inventory is hidden when game starts
                            document.getElementById('inventoryPanel').style.display = 'none';
                            // <-- Show stats display when game starts -->
                            const statsDisplayElement = document.getElementById('playerStatsDisplay');
                            if (statsDisplayElement) {
                                statsDisplayElement.style.display = 'block'; // Show stats
                                updateStatsDisplay(); // Update with any previously received stats
                            }
                            break;
                        case "Lobby":
                            exitCombatMode();
                            document.getElementById('gameView').style.display = 'none';
                            document.getElementById('lobbyView').style.display = 'block';
                            // <-- Hide stats display when back to lobby -->
                            const statsDisplayElementLobby = document.getElementById('playerStatsDisplay');
                            if (statsDisplayElementLobby) {
                                statsDisplayElementLobby.style.display = 'none';
                            }
                            break;

                        case "Combat":
                            enterCombatMode();
                            break;
                        // add other states if you need them
                    }
                    break;

                case "inventory_update":
                    // Pass the entire message object, not just msg.items
                    handleInventoryData(msg);
                    break;

                // <-- case for stats_update -->
                case "stats_update":
                    // Store the received stats data, including level and experience
                    // Ensure playerStats.name is set correctly on join_success or elsewhere if needed
                    playerStats.name = playerStats.name || "Player"; // Use existing name or default
                    // Update stats only if they are present in the message
                    if (msg.hasOwnProperty('role')) playerStats.class = msg.role; // this is role cause cant send class in C
                    if (msg.hasOwnProperty('level')) playerStats.level = msg.level;
                    if (msg.hasOwnProperty('experience')) playerStats.experience = msg.experience; // Handle XP update
                    if (msg.hasOwnProperty('currentHealth')) playerStats.currentHealth = msg.currentHealth;
                    if (msg.hasOwnProperty('maxHealth')) playerStats.maxHealth = msg.maxHealth;
                    if (msg.hasOwnProperty('attack')) playerStats.attack = msg.attack;
                    if (msg.hasOwnProperty('defense')) playerStats.defense = msg.defense;
                    if (msg.hasOwnProperty('magic')) playerStats.magic = msg.magic;

                    // Update the display with the new stats
                    updateStatsDisplay();
                    break;
                    // <-- End of stats_update case -->

                case "encounter_start":
                    if (isInCombat) {
                        currentCombatState = msg; // Store the full encounter data
                        logCombatMessage(msg.message, "system");
                        updatePlayerListCombat(msg.players);
                        updateEnemyListCombat(msg.enemies);
                        // Highlight initial turn entity if included or wait for turn_start
                        if (msg.turnOrder && msg.turnOrder.length > 0) {
                            // Maybe highlight the first entity or wait for turn_start
                            // highlightCurrentTurnEntity(msg.turnOrder[0]); // Example
                        }
                    }
                    break;

                case 'encounter_end': // Message sent by CombatService/EncounterManager
                    isInCombat = false;
                    // msg might contain result (victory/defeat)
                    logCombatMessage(`Encounter ended. Result: ${msg.result}`, "system");
                    // Maybe show a victory/defeat message or automatically transition?
                    break;

                // Inside the main message switch statement
                case "turn_start":
                    if (isInCombat && currentCombatState) {
                        logCombatMessage(msg.message, "system");
                        highlightCurrentTurnEntity(msg.entity); // Implement this function

                        const availableActionsDiv = document.getElementById('availableActions');
                        if (availableActionsDiv) {
                            availableActionsDiv.innerHTML = ''; // Clear previous actions

                            // Check if it's the CURRENT PLAYER'S turn
                            if (msg.entity.type === "player" && msg.entity.id === currentPlayerId) {
                                logDebug("It's my turn! Enabling actions.");

                                // --- Add Action Buttons ---
                                // 1. Basic Attack
                                const attackBtn = document.createElement('button');
                                attackBtn.className = 'combat-action-btn';
                                attackBtn.textContent = 'Melee Attack';
                                attackBtn.onclick = () => sendCombatAction('melee_attack', {}); // Requires target selection
                                availableActionsDiv.appendChild(attackBtn);

                                // 2. Defend (Example)
                                const defendBtn = document.createElement('button');
                                defendBtn.className = 'combat-action-btn';
                                defendBtn.textContent = 'Defend';
                                defendBtn.onclick = () => sendCombatAction('defend', {});
                                availableActionsDiv.appendChild(defendBtn);

                                // 3. Use Item (Potions) - Requires inventory data and target selection
                                // Iterate through inventoryData (assuming it's updated) to find usable items
                                if (Array.isArray(inventoryData)) {
                                    inventoryData.forEach(item => {
                                        // Assuming item has properties like type, isConsumable, etc.
                                        if (item.isConsumable) { // Define your criteria
                                            const useItemBtn = document.createElement('button');
                                            useItemBtn.className = 'combat-action-btn';
                                            useItemBtn.textContent = `Use ${item.name}`;
                                            useItemBtn.dataset.itemId = item.id; // Store item ID
                                            useItemBtn.onclick = () => {
                                                // Example: Simple use on self, or prompt for target
                                                // For simplicity, assume self-target or add target selection logic
                                                sendCombatAction('use_item', { itemId: item.id /*, targetId: currentPlayerId */ });
                                            };
                                            availableActionsDiv.appendChild(useItemBtn);
                                        }
                                    });
                                }

                                // 4. Use Ability (Magic/Spells) - Requires player abilities data
                                // You'd need to track player abilities (sent by server?) and create buttons similarly.
                                // Example (assuming playerStats has an 'abilities' array sent by server):
                                // if (Array.isArray(playerStats.abilities)) {
                                //   playerStats.abilities.forEach(ability => {
                                //     const useAbilityBtn = document.createElement('button');
                                //     useAbilityBtn.className = 'combat-action-btn';
                                //     useAbilityBtn.textContent = ability.name;
                                //     useAbilityBtn.dataset.abilityId = ability.id;
                                //     useAbilityBtn.onclick = () => sendCombatAction('use_ability', { abilityId: ability.id /*, targetId: ... */ });
                                //     availableActionsDiv.appendChild(useAbilityBtn);
                                //   });
                                // }

                                // --- Target Selection ---
                                // You will likely need logic to let the player *select* a target
                                // (player or enemy) after clicking an action like Attack or Use Item.
                                // This could involve:
                                // - Adding a "Select Target" message to the log.
                                // - Adding click handlers to player/enemy entries in their lists.
                                // - Storing the selected target ID.
                                // - Modifying sendCombatAction to include the targetId.
                                // For now, actions like melee_attack will need target selection logic.
                                logDebug("Please select a target for your action.");

                            } else {
                                logDebug(`It's ${msg.entity.name}'s turn (${msg.entity.type}).`);
                                // Optionally disable action buttons or show a "Wait for your turn" message
                                // inside availableActionsDiv
                            }
                        }
                    }
                    break;

                case 'stats_update':
                    // This might be sent for players or enemies during combat
                    // Update the relevant HP bar in the combat view
                    updateCombatantStats(msg); // Implement this function
                    break;

                case 'ability_effect':
                    // This message contains the result of an ability (damage, heal, etc.)
                    logCombatMessage(msg.message, "system"); // Or determine player/enemy source
                    // If msg contains numerical data, update stats here too
                    if (msg.targetStats) { // Example: server sends updated target stats
                        updateCombatantStats(msg.targetStats);
                    }
                    break;

                case 'combat_log': // Specific log messages from server
                    logCombatMessage(msg.message, msg.category || "system"); // category could be 'player', 'enemy', 'damage', 'heal'
                    break;

                default:
                    logDebug(`Unknown message type: ${msg.type}`);
            }
        }
        /* helper to send WS messages */
        function sendMessage(payload) {
            if (ws && ws.readyState === 1) ws.send(JSON.stringify(payload));
        }


        function enterCombatMode() {
            document.getElementById('combatPanel').style.display = 'block';
            // Hide main game stats if separate
            const statsDisplay = document.getElementById('playerStatsDisplay');
            if (statsDisplay) statsDisplay.style.display = 'none';

            // Ensure inventory panel is hidden initially when entering combat
            document.getElementById('inventoryPanel').style.display = 'none';
            // Make sure the inventory button is visible (or add one to combat panel)
            document.getElementById('inventoryButton').style.display = 'block'; // Or adjust as needed

            // Clear previous state/logs
            clearCombatLog();
            // Clear player/enemy lists if needed
            if (document.getElementById('playerListCombat')) document.getElementById('playerListCombat').innerHTML = '';
            if (document.getElementById('enemyListCombat')) document.getElementById('enemyListCombat').innerHTML = '';
            if (document.getElementById('availableActions')) document.getElementById('availableActions').innerHTML = '';

            isInCombat = true;
            currentCombatState = null;
            logDebug("Entered combat mode.");
            // Wait for 'encounter_start' message to populate UI
        }

        function exitCombatMode() {
            document.getElementById('combatPanel').style.display = 'none';
            isInCombat = false;
            currentCombatState = null;
            clearCombatLog();
            logDebug("Exited combat mode.");
            // Show other UI elements again if they were hidden
        }

        function updateCombatView(data) {
            // This function updates the entire combat panel or parts of it based on data received
            if (data.players) {
                updatePlayerListCombat(data.players);
            }
            if (data.enemies) {
                updateEnemyListCombat(data.enemies);
            }
            if (data.currentTurnEntity) {
                highlightCurrentTurnEntity(data.currentTurnEntity); // Implement this
            }
            if (data.turnOrder) {
                // Update a turn order display if you have one
            }
            // Update other parts of the UI as needed based on the data structure
        }

        function updatePlayerListCombat(players) {
            const container = document.getElementById('playerListCombat');
            if (!container) return;
            container.innerHTML = '';
            
            players.forEach(playerData => {
                const playerEl = document.createElement('div');
                playerEl.className = `combatant player`;
                playerEl.dataset.playerId = playerData.id;
                
                // Name and Class
                const nameEl = document.createElement('div');
                nameEl.className = 'combatant-header';
                nameEl.innerHTML = `<strong>${playerData.name}</strong> <span class="combatant-class">${playerData.class || 'Adventurer'}</span>`;
                
                // Stats Row
                const statsEl = document.createElement('div');
                statsEl.className = 'combatant-stats';
                statsEl.innerHTML = `
                    <span class="stat">ATK: ${playerData.attack || 0}</span>
                    <span class="stat">DEF: ${playerData.defense || 0}</span>
                    <span class="stat">MAG: ${playerData.magic || 0}</span>
                `;
                
                // Health Bar (from old version)
                const hpBarEl = document.createElement('div');
                hpBarEl.className = 'hp-bar';
                const hpFillEl = document.createElement('div');
                hpFillEl.className = 'hp-fill';
                const hpPercent = (playerData.currentHealth / playerData.maxHealth) * 100;
                hpFillEl.style.width = `${hpPercent}%`;
                const hpTextEl = document.createElement('span');
                hpTextEl.className = 'hp-text';
                hpTextEl.textContent = `${playerData.currentHealth}/${playerData.maxHealth}`;
                
                hpBarEl.appendChild(hpFillEl);
                hpBarEl.appendChild(hpTextEl);
                
                // Assemble everything
                playerEl.appendChild(nameEl);
                playerEl.appendChild(statsEl);
                playerEl.appendChild(hpBarEl);
                container.appendChild(playerEl);
            });
        }

        function updateEnemyListCombat(enemies) {
            const container = document.getElementById('enemyListCombat');
            if (!container) return;
            container.innerHTML = '';
            
            enemies.forEach(enemyData => {
                const enemyEl = document.createElement('div');
                enemyEl.className = `combatant enemy`;
                enemyEl.dataset.enemyId = enemyData.id;
                
                // Name
                const nameEl = document.createElement('div');
                nameEl.className = 'combatant-header';
                nameEl.innerHTML = `<strong>${enemyData.name || "Unknown Enemy"}</strong>`;
                
                // Stats Row
                const statsEl = document.createElement('div');
                statsEl.className = 'combatant-stats';
                statsEl.innerHTML = `
                    <span class="stat">ATK: ${enemyData.attack || 0}</span>
                    <span class="stat">DEF: ${enemyData.defense || 0}</span>
                    <span class="stat">MAG: ${enemyData.magic || 0}</span>
                `;
                
                // Health Bar (from old version with color changes)
                const hpBarEl = document.createElement('div');
                hpBarEl.className = 'hp-bar';
                const hpFillEl = document.createElement('div');
                hpFillEl.className = 'hp-fill';
                const hpPercent = enemyData.maxHealth > 0 ? (enemyData.currentHealth / enemyData.maxHealth) * 100 : 0;
                hpFillEl.style.width = `${hpPercent}%`;
                
                // Dynamic health bar coloring
                if (hpPercent < 30) {
                    hpFillEl.style.background = 'linear-gradient(to right, #f44336, #f44336)';
                } else if (hpPercent < 60) {
                    hpFillEl.style.background = 'linear-gradient(to right, #f44336, #FFC107)';
                }
                
                const hpTextEl = document.createElement('span');
                hpTextEl.className = 'hp-text';
                hpTextEl.textContent = `${enemyData.currentHealth}/${enemyData.maxHealth}`;
                
                hpBarEl.appendChild(hpFillEl);
                hpBarEl.appendChild(hpTextEl);
                
                // Assemble everything
                enemyEl.appendChild(nameEl);
                enemyEl.appendChild(statsEl);
                enemyEl.appendChild(hpBarEl);
                container.appendChild(enemyEl);
            });
        }

        function updateActionButtons(currentEntityName) {
            // Assume player's name is stored in a global like playerName
            const actionContainer = document.getElementById('availableActions');
            actionContainer.innerHTML = ''; // Clear previous actions

            // This is simplified. You'd need the player's available abilities/items.
            // For now, let's assume actions are enabled only on the player's turn.
            if (currentEntityName === playerName) { // Make sure playerName is accessible here
                // Add basic action buttons
                const attackBtn = document.createElement('button');
                attackBtn.className = 'combat-action-btn';
                attackBtn.textContent = 'Melee Attack';
                attackBtn.dataset.action = 'melee_attack';
                attackBtn.onclick = () => sendCombatAction('melee_attack');

                const potionBtn = document.createElement('button'); // Example, check inventory
                potionBtn.className = 'combat-action-btn';
                potionBtn.textContent = 'Use Potion';
                potionBtn.dataset.action = 'use_item';
                potionBtn.dataset.itemId = 'health_potion_01'; // Hardcoded example
                potionBtn.onclick = () => sendCombatAction('use_item', { itemId: 'health_potion_01' });
                // Disable if no potions? Check inventory state.

                // Add ability buttons dynamically based on player's unlocked abilities
                // You'd need to track unlocked abilities in JS, perhaps sent by the server.
                // Example:
                // if (playerUnlockedAbilities.includes('fireball')) {
                //     const fireballBtn = document.createElement('button');
                //     fireballBtn.className = 'combat-action-btn';
                //     fireballBtn.textContent = 'Fireball';
                //     fireballBtn.dataset.action = 'use_ability';
                //     fireballBtn.dataset.abilityId = 'fireball';
                //     fireballBtn.onclick = () => sendCombatAction('use_ability', { abilityId: 'fireball', target: 'enemy_1' }); // Targeting needed
                //     actionContainer.appendChild(fireballBtn);
                // }

                actionContainer.appendChild(attackBtn);
                actionContainer.appendChild(potionBtn);
                // Add other buttons...
            } else {
                // Not player's turn, disable or hide action buttons
                const waitMessage = document.createElement('div');
                waitMessage.textContent = "Waiting for your turn...";
                waitMessage.style.color = '#888';
                waitMessage.style.fontStyle = 'italic';
                actionContainer.appendChild(waitMessage);
            }
        }

        function sendCombatAction(actionType, details = {}) {
            // Send the player's chosen action to the server

            if (!isInCombat || !currentPlayerId) {
                logDebug("Cannot send action: Not in combat or player ID unknown.");
                return;
            }
            const actionMessage = {
                type: "combat_action", // Message type for PlayerManager->CombatService
                action_type: actionType, // e.g., "melee_attack", "use_ability", "use_item"
                ...details // e.g., { abilityId: "fireball", target: "enemy_1" } or { itemId: "health_potion_01" }
            };
            sendMessage(actionMessage);
            logCombatMessage(`You used ${actionType}.`, "player");
        }

        function logCombatMessage(message, category = "system") {
            const logContainer = document.getElementById('combatLogEntries');
            const entryEl = document.createElement('div');
            entryEl.className = `combat-log-entry combat-log-${category}`;
            entryEl.textContent = `[${new Date().toLocaleTimeString()}] ${message}`;
            logContainer.appendChild(entryEl);
            logContainer.scrollTop = logContainer.scrollHeight; // Auto-scroll to bottom
        }

        function clearCombatLog() {
            const logContainer = document.getElementById('combatLogEntries');
            logContainer.innerHTML = '';
        }

        function updateCombatantStats(statsUpdateData) {
            // statsUpdateData is expected to have id, currentHealth, maxHealth
            if (!statsUpdateData.id) return;

            // Try to find the corresponding element (player or enemy)
            let combatantEl = document.querySelector(`.combatant[data-player-id="${statsUpdateData.id}"]`) ||
                            document.querySelector(`.combatant[data-enemy-id="${statsUpdateData.id}"]`);

            if (combatantEl) {
                const hpBarEl = combatantEl.querySelector('.hp-bar');
                const hpFillEl = combatantEl.querySelector('.hp-fill');
                const hpTextEl = combatantEl.querySelector('.hp-text');

                if (hpBarEl && hpFillEl && hpTextEl && statsUpdateData.maxHealth > 0) {
                    const hpPercent = (statsUpdateData.currentHealth / statsUpdateData.maxHealth) * 100;
                    hpFillEl.style.width = `${hpPercent}%`;
                    hpTextEl.textContent = `${statsUpdateData.currentHealth}/${statsUpdateData.maxHealth}`;

                    // Update color based on new HP
                    if (hpPercent < 30) {
                        hpFillEl.style.background = 'linear-gradient(to right, #f44336, #f44336)';
                    } else if (hpPercent < 60) {
                        hpFillEl.style.background = 'linear-gradient(to right, #f44336, #FFC107)';
                    } else {
                        // Reset to default gradient if needed, or keep the default CSS one
                        hpFillEl.style.background = ''; // Relies on CSS default
                    }
                }
            }
        }



        function highlightCurrentTurnEntity(entityInfo) {
            // Remove highlight from all player and enemy entries first
            const playerEntries = document.querySelectorAll('#playerListCombat > div');
            const enemyEntries = document.querySelectorAll('#enemyListCombat > div');
            playerEntries.forEach(el => el.classList.remove('current-turn'));
            enemyEntries.forEach(el => el.classList.remove('current-turn'));

            // Find and highlight the correct entry
            let targetElement = null;
            if (entityInfo.type === 'player') {
                targetElement = document.querySelector(`#playerListCombat > div[data-player-id="${entityInfo.id}"]`);
            } else if (entityInfo.type === 'enemy') {
                targetElement = document.querySelector(`#enemyListCombat > div[data-enemy-id="${entityInfo.id}"]`);
            }

            if (targetElement) {
                targetElement.classList.add('current-turn');
            }
        }

        // ... (rest of your existing JS functions) ...












        function updatePlayerList(players) {
            const listElement = document.getElementById('playerList');
            listElement.innerHTML = '';
            
            players.forEach(player => {
                const entry = document.createElement('div');
                entry.className = `player-entry ${player.IsReady ? 'ready' : ''}`;
                
                const playerInfo = document.createElement('div');
                playerInfo.className = 'player-info';
                playerInfo.innerHTML = `
                    <span><b>${player.Name}</b></span>
                    <span>${player.Role}</span>
                    <span>${player.IsReady ? 'READY' : 'waiting'}</span>
                `;
                
                entry.appendChild(playerInfo);
                listElement.appendChild(entry);
            });
        }

        function toggleReady() {
            isReady = !isReady;
            const message = {
                type: "set_ready",
                isReady: isReady
            };
            console.log("Sending ready message:", message);
            ws.send(JSON.stringify(message));
            document.getElementById('readyButton').textContent = isReady ? "Unready" : "Ready Up";
            logDebug(`Set ready state to ${isReady}`);
        }

        function startGame() {
            ws.send(JSON.stringify({ type: "start_game" }));
            logDebug("Sent start game request");
        }

        function disconnect() {
            if (ws) {
                logDebug("Disconnecting...");
                ws.close();
            }
        }

        debugInterval = setInterval(() => {
            if (ws) {
                logDebug(`Connection state: ${ws.readyState}`);
            }
        }, 5000);
    </script>
</body>
</html>